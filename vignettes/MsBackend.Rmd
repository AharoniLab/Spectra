---
title: "Creating new `MsBackend` classes"
output:
    BiocStyle::html_document:
        toc_float: true
vignette: >
    %\VignetteIndexEntry{Creating new `MsBackend` class}
    %\VignetteEngine{knitr::rmarkdown}
    %\VignetteEncoding{UTF-8}
    %\VignettePackage{Spectra}
    %\VignetteDepends{Spectra,BiocStyle}
bibliography: references.bib
---

```{r style, echo = FALSE, results = 'asis', message=FALSE}
BiocStyle::markdown()
```

**Package**: `r Biocpkg("Spectra")`<br />
**Authors**: `r packageDescription("Spectra")[["Author"]] `<br />
**Last modified:** `r file.info("Spectra.Rmd")$mtime`<br />
**Compiled**: `r date()`

```{r, echo = FALSE, message = FALSE}
library(Spectra)
library(BiocStyle)
```

# Introduction

This vignette briefly describes the `MsBackend` class which is used by the
`Spectra` package to *represent* and provide Mass Spectrometry (MS) data and
illustrates how a new such *backend* class can be created and tested for
validity.


# What is a `MsBackend`?

The `Spectra` package separates the code for the analysis of MS data from the
code needed to import, represent and provide the data. The former is implemented
for the `Spectra` class which is the main object users will use for their
analyses. The `Spectra` object relies on a so-called *backend* to provide the MS
data. The `MsBackend` virtual class defines the API that new *backend* classes
need to implement in order to be used with the `Spectra` object. Each `Spectra`
object contains an implementation of such a `MsBackend` within its `@backend`
slot which provides the MS data to the `Spectra` object. All data management is
thus hidden from the user. In addition this separation allows to define new,
alternative, data representations and integrate them seamlessly into a
`Spectra`-based data analysis workflow.

This whole concept is an extension of the of *in-memory* and *on-disk* data
representations from the `r Biocpkg("MSnbase")` package
[@gattoMSnbaseEfficientElegant2020a].

## Conventions and definitions

General conventions for MS data of a `Spectra` are:

- One `Spectra` object is supposed to contain MS (spectral) data of multiple
  MS spectra.
- m/z values within each spectrum are expected to be sorted increasingly.
- Missing values (`NA`) for m/z values are not supported.
- Properties of a spectrum are called *spectra variables*. While backends can
  define their own properties, a minimum required set of spectra variables must
  be provided by each backend (even if their values are empty). These *core*
  spectra variables along with their data type are listed by the
  `coreSpectraVariables()` function.
- `dataStorage` and `dataOrigin` are two special spectra variables that define
  for each spectrum where the data is stored and from where the data derived (or
  was loaded, such as the data origin). Both are expected to be of
  type`character` and need to be defined by the backend (i.e. they can not be
  empty or missing).
- `MsBackend` implementations can also represent purely *read-only* data
  resources. In this case only data accessor methods need to be implemented but
  not data replacement methods. Whether a backend is read-only can be set with
  the `@readonly` slot of the virtual `MsBackend` class. The default is
  `@readonly = FALSE` and thus all data replacement method listed in section
  *Data replacement methods* have also to be implemented. For read-only backends
  (`@readonly = TRUE`) only the methods in section *Required methods* need to be
  implemented.


# API

The `MsBackend` class defines core methods that have to be implemented by a
MS *backend* as well as *optional* methods with default implementations that
might be implemented for a new backend but don't necessarily have to. These
functions are described in sections *Required methods* and *Optional methods*, respectively.

To create a new backend a class extending the virtual `MsBackend` needs to be
implemented. In the example below we create thus a simple class with a
`data.frame` to contain general spectral properties (*spectra variables*) and
two slots for m/z and intensity values. These are stored as `NumericList`
objects since both m/z and intensity values are expected to be of type `numeric`
and to allow to store data from multiple spectra into a single backend
object. We also define a simple constructor function that returns an empty
instance of our new class.


```{r, message = FALSE}
library(Spectra)
library(IRanges)

setClass("MsBackendTest",
         contains = "MsBackend",
         slots = c(
             spectraVars = "data.frame",
             mz = "NumericList",
             intensity = "NumericList"
         ),
         prototype = prototype(
             spectraVars = data.frame(),
             mz = NumericList(compress = FALSE),
             intensity = NumericList(compress = FALSE)
         ))

MsBackendTest <- function() {
    new("MsBackendTest")
}
```

The 3 slots `spectraVars`, `mz` and `intensity` will be used to store our MS
data, each row in `spectraVars` being data for one spectrum with the columns
being the different *spectra variables* (i.e. additional properties of a
spectrum such as its retention time or MS level) and each element in `mz` and
`intensity` being a `numeric` with the m/z and intensity values of the
respective spectrum.

We should ideally also add some basic validity function that ensures the data to
be OK. The function below simply checks that the number of rows of the
`spectraVars` slot matches the length of the `mz` and `intensity` slot.

```{r, message = FALSE}
setValidity("MsBackendTest", function(object) {
    if (length(object@mz) != length(object@intensity) ||
        length(object@mz) != nrow(object@spectraVars))
        return("length of 'mz' and 'intensity' has to match the number of ",
               "rows of 'spectraVars'")
    NULL
})

```

We can now create an instance of our new class with the `MsBackendTest`
function.

```{r}
MsBackendTest()
```

Note that a *backend* class does not necessarily need to contain all the data
like the one from our example. Backends such as the `MsBackendMzR` for example
retrieve the data on the fly from the raw MS data files or the `MsBackendSql`
from the `r Biocpkg("MsBackendSql")` a SQL database.


## Required methods

Methods listed in this section must be implemented for a new class extending
`MsBackend`. Methods should ideally also implemented in the order they are
listed here. Also, it is strongly advised to write dedicated unit tests for
each newly implemented method or function already **during** the development.


### `dataStorage`

The `dataStorage` spectra variable of a spectrum provides some information how
or where the data is stored. The `dataStorage` method should therefor return a
`character` vector with length equal to the number of spectra of a backend
object with that information. For most backends the data storage information can
be a simple string such as `"memory"` or `"database"` to specify that the data
of a spectrum is stored within the object itself or in a database,
respectively.

Backend classes that keep only a subset of the MS data in memory and need to
load data from data files upon request will use this spectra variable to store
and keep track of the original data file for each spectrum. An example is the
`MsBackendMzR` backend that retrieves the MS data on-the-fly from the original
data file(s) whenever m/z or intensity values are requested from the
backend. Calling `dataStorage` on an `MsBackendMzR` returns thus the names from
the originating files.

For our example backend we define a simple `dataStorage` method that simply
returns the column `"dataStorage"` from the `@svars` (as a `character`).

```{r}
setMethod("dataStorage", "MsBackendTest", function(object) {
    as.character(object@spectraVars$dataStorage)
})
```


### `length`

`length` is expected to return a single `integer` with the total number of
spectra that are available through the backend class. For our example backend we
simply return the number of rows of the `data.frame` stored in the
`@spectraVars` slot.

```{r}
setMethod("length", "MsBackendTest", function(x) {
    nrow(x@spectraVars)
})
```


### `backendInitialize`

The `backendInitialize` method is expected to be called after creating an
instance of the backend class and should prepare (initialize) the backend which
in most cases means that MS data is loaded. This method can take any parameters
needed by the backend to get loaded/initialized with data (which can be file
names from which to load the data, a database connection or object(s) containing
the data). During `backendInitialize` usually also the special spectra variables
`dataStorage` and `dataOrigin` are set.

Below we define a `backendInitialize` method that takes as arguments a
`data.frame` with spectra variables and two `list`s with the m/z and intensity
values for each spectrum.

```{r}
setMethod(
    "backendInitialize", "MsBackendTest",
    function(object, svars, mz, intensity) {
        if (!is.data.frame(svars))
            stop("'svars' needs to be a 'data.frame' with spectra variables")
        svars$dataStorage <- "<memory>"
        if (is.null(svars$dataOrigin))
            svars$dataOrigin <- "<user provided>"
        object@spectraVars <- svars
        object@mz <- NumericList(mz, compress = FALSE)
        object@intensity <- NumericList(intensity, compress = FALSE)
        validObject(object)
        object
    })
```

In addition to adding the data to object, the function also defined the
`dataStorage` and `dataOrigin` spectra variables. The purpose of these two
variables is to provide some information on where the data is stored (*in
memory* as in our example) and from where the data is originating. The
`dataOrigin` would for example allow to specify from which original data files
individual spectra derive.

We can now create an instance of our backend class and fill it with data. We
thus first define our MS data and pass this to the `backendInitialize` method.

```{r}
## A data.frame with spectra variables.
svars <- data.frame(msLevel = c(1L, 2L, 2L),
                    rtime = c(1.2, 1.3, 1.4))
## m/z values for each spectrum.
mzs <- list(c(12.3, 13.5, 16.5, 17.5),
            c(45.1, 45.2),
            c(64.4, 123.1, 124.1))
## intensity values for each spectrum.
ints <- list(c(123.3, 153.6, 2354.3, 243.4),
             c(100, 80.1),
             c(12.3, 35.2, 100))

## Create and initialize the backend
be <- backendInitialize(MsBackendTest(),
                        svars = svars, mz = mzs, intensity = ints)
be
```

The `backendInitialize` method for our backend class thus expects the user to
provide the full MS data. This does however not always have to be the case. The
`backendInitialize` method of the `MsBackendMzR` backend takes for example the
file names of the raw mzML, mzXML or CDF files as input and initializes the
backend by importing part of the data from these. Also the backends defined by
the `r Biocpkg("MsBackendMgf")` or `r Biocpkg("MsBackendMsp")` packages work in
the same way and thus allow to import MS data from these specific file
formats. The `backendInitialize` method of the backend defined in the
`r Biocpkg("MsBackendSql")` on the other hand takes only the connection to a
database containing the data as input and performs some sanity checks on the
data but does not load the data into the backend. Any subsequent data access is
handled by the methods of the backend class through SQL calls to the database.

The purpose of the `backendInitialize` method is to *initialize* and prepare the
data in a way that it can be accessed by a `Spectra` object (through the
initialized backend class). Whether the data is loaded by the
`backendInitialize` method into memory or simply referenced to within the
backend class does not matter as long as the backend is able to provide the data
with its accessor methods.

Note also that a `backendInitialize` function should ideally also perform some
data sanity checks (e.g. whether spectra variables have the correct data type
etc).


### `spectraVariables`

The `spectraVariables` method should return a `character` vector with the names
of all available spectra variables of the backend. While a backend class should
support defining and providing their own spectra variables, each `MsBackend`
class **must** provide also the *core spectra variables* (in the correct data
type). Since not all data file formats provide values for all these spectra
variables they can however also be `NA` (with the exception of the spectra
variable `"dataStorage"`).

The `coreSpectraVariables()` function returns the full list of mandatory spectra
variables along with their expected data type.

```{r}
coreSpectraVariables()
```

A typical `spectraVariables` method for a `MsBackend` class will thus be
implemented similarly to the one for our `MsBackendTest` test backend: it will
return the union of the core spectra variables and the names for all available
spectra variables within the backend object.

```{r}
setMethod("spectraVariables", "MsBackendTest", function(object) {
    union(names(coreSpectraVariables), colnames(object@spectraVars))
})
```


### `spectraData`

The `spectraData` method should return the **full** spectra data within a
backend as a `DataFrame` object (defined in the `r Biocpkg("S4Vectors")`
package). The second parameter `columns` allows to define the names of the
spectra variables that should be returned in the `DataFrame`. Each row in this
data frame should represent one spectrum, each column a spectra
variable. Columns `"mz"` and `"intensity"` (if requested) have to contain each a
`NumericList` with the m/z and intensity values of the spectra. The `DataFrame`
**must** provide values (even if they are `NA`) for **all** requested spectra
variables of the backend (**including** the core spectra variables).

This is now a first problem for our toy backend class, since we keep the spectra
variable data in a simple `data.frame` without any constraints such as required
columns etc. A simple solution to this (which is also used by all backend
classes in the `Spectra` package) is to *fill* missing spectra variables
on-the-fly into the returned `DataFrame`. We thus define below a simple helper
function that adds columns with missing values (of the correct data type) for
core spectra variables that are not available within the backend to the result.

```{r}
#' @description Add columns with missing core spectra variables.
#'
#' @param x `data.frame` or `DataFrame` with some spectra variables.
#'
#' @param core_vars `character` with core spectra variable names that should
#'     be added to `x` if not already present.
#'
.fill_core_variables <- function(x, core_vars = names(coreSpectraVariables())) {
    fill_vars <- setdiff(core_vars, colnames(x))
    core_type <- coreSpectraVariables()
    n <- nrow(x)
    if (length(fill_vars)) {
        fill <- lapply(fill_vars, function(z) {
            rep(as(NA, core_type[z]), n)
        })
        names(fill) <- fill_vars
        x <- cbind(x, as.data.frame(fill))
    }
    x
}
```

We next implement the `spectraData` method that uses this helper function to
fill eventually missing core spectra variables. Note also that this function
should return a `DataFrame` even for a single column.

```{r}
setMethod(
    "spectraData", "MsBackendTest",
    function(object, columns = spectraVariables(object)) {
        if (!all(columns %in% spectraVariables(object)))
            stop("Some of the requested spectra variables are not available")
        ## Add m/z and intensity values to the result
        res <- DataFrame(object@spectraVars)
        res$mz <- object@mz
        res$intensity <- object@intensity
        ## Fill with eventually missing core variables
        res <- .fill_core_variables(
            res, intersect(columns, names(coreSpectraVariables())))
        res[, columns, drop = FALSE]
})
```

As an alternative, we could also initialize the `@spectraVars` data frame within
the `backendInitialize` method adding columns for spectra variables that are not
provided by the user and require that this data frame always contains all core
spectra variables. Extracting spectra data (single spectra variables or the full
data) might thus be more efficient then the on-the-fly initialization with
eventual missing spectra variables, but the backend class would also have a
larger memory footprint because even spectra variables with only missing values
for all spectra need to be stored within the object.

We can now use `spectraData` to either extract the full spectra data from the
backend, or only the data for selected spectra variables.

```{r}
## Full data
spectraData(be)

## Selected variables
spectraData(be, c("rtime", "mz", "centroided"))

## Only missing core spectra variables
spectraData(be, c("centroided", "polarity"))
```


### `peaksData`

The `peaksData` method extracts the MS peaks data from a backend, which includes
the m/z and intensity values of each MS peak of a spectrum. These are expected
to be returned as a `List` of numerical matrices with columns in each `matrix`
being the requested *peaks variables* (with the default being `"mz"` and
`"intensity"`) of one spectrum. Backends must provide at least these two peaks
variables.

Below we implement the `peaksData` method for our backend. We need to loop over
the `@mz` and `@intensity` slots to merge the m/z and intensity of each spectrum
into a `matrix`. Also, for simplicity reasons, we accept only
`c("mz", "intensity")` for the `columns` parameter. This is the expected default
behavior for a `MsBackend`, but in general the `columns` parameter is thought to
allow the user to specify which peaks variables should be returned in each
`matrix`.

```{r}
setMethod(
    "peaksData", "MsBackendTest",
    function(object, columns = c("mz", "intensity")) {
        if (length(columns) != 2 && columns != c("mz", "intensity"))
            stop("'columns' supports only \"mz\" and \"intensity\"")
        mapply(mz = object@mz, intensity = object@intensity,
               FUN = cbind, SIMPLIFY = FALSE, USE.NAMES = FALSE)
    })
```

And with this method we can now extract the peaks data from our backend.

```{r}
peaksData(be)
```

The `peaksData` method is used in many data analysis functions of the `Spectra`
object to extract the MS data, thus ideally this method should be implemented in
an efficient way. For our backend we need to loop over the lists of m/z and
intensity values which is obviously not ideal. Thus, storing the m/z and
intensity values in separate slots as done in this backend might not be
ideal. The `MsBackendMemory` backend for example stores the MS data already as
a `list` of matrices which results in a more efficient `peaksData` method (but
comes also with a larger overhead when adding, replacing or checking MS data).

Note also that while a backend needs to provide m/z and intensity values,
additional peak variables would also be supported. The `MsBackendMemory` class
for example allows to store and provide additional peak variables that can then
be added as additional columns to each returned `matrix`. In this case the
default `peaksVariables` method should also be overwritten to list the
additionally available variables and the `columns` parameter of the `peaksData`
method should allow selection of these additional peaks variables (in addition
to the required `"mz"` and `"intensity"` variables).


### `[`

The `[` method allows to subset `MsBackend` objects. This operation is expected
to reduce a `MsBackend` object to the selected spectra. The method should
support to subset by indices or logical vectors and should also support
duplicating elements (i.e. when duplicated indices are used) as well as to
subset in arbitrary order.

Below we implement a possible `[` for our test backend class. We ignore the
parameters `j` from the definition of the `[` generic, since we treat our data
to be one-dimensional (with each spectrum being one element).

```{r}
setMethod("[", "MsBackendTest", function(x, i, j, ..., drop = FALSE) {
    x@spectraVars <- x@spectraVars[i, ]
    x@mz <- x@mz[i]
    x@intensity <- x@intensity[i]
    x
})
```

We can now subset our backend to the last two spectra.

```{r}
a <- be[2:3]
spectraData(a)
```

Or extracting the second spectrum multiple times.

```{r}
a <- be[c(2, 2, 2)]
spectraData(a)
```


### `backendMerge`

The `backendMerge` method merges (combines) `MsBackend` objects (of the same
type!) into a single instance. For our test backend we thus need to combine the
values in the `@spectraVars`, `@mz` and `@intensity` slots. To support also
merging of `data.frame`s with different set of columns we use the
`MsCoreUtils::rbindFill` function instead of a simple `rbind` (this function
joins data frames making an union of all available columns).

```{r}
setMethod("backendMerge", "MsBackendTest", function(object, ...) {
    res <- object
    object <- unname(c(object, ...))
    res@mz <- do.call(c, lapply(object, function(z) z@mz))
    res@intensity <- do.call(c, lapply(object, function(z) z@intensity))
    res@spectraVars <- do.call(MsCoreUtils::rbindFill,
                               lapply(object, function(z) z@spectraVars))
    validObject(res)
    res
})
```

Again, this implementation which requires 3 loops might not be the most
efficient - but it allows to merge backends of the type `MsBackendTest`.

```{r}
a <- backendMerge(be, be[2], be)
a
```


### `$`

The `$` method is expected to extract a single spectra variable from a
backend. Parameter `name` should allow to name the spectra variable to
return. Each `MsBackend` **must** support extracting the core spectra variables
with this method (even if no data might be available for that variable). In our
example implementation below we make use of the `spectraData` method, but more
efficient implementations might be available as well (with less subsetting
operations).

```{r}
setMethod("$", "MsBackendTest", function(x, name) {
    spectraData(x, columns = name)[, 1L]
})
```

With this we can now extract the MS levels

```{r}
be$msLevel
```

or a core spectra variable that is not available within the backend.

```{r}
be$precursorMz
```

or also the m/z values

```{r}
be$mz
```


### `lengths`

The `lengths` method is expected to return an `integer` vector (same length as
the number of spectra in the backend) with the total number of peaks per
spectrum.

For our `MsBackendTest` we can simply use the `lengths` method on the m/z or
intensity values for that.

```{r}
setMethod("lengths", "MsBackendTest", function(x, use.names = FALSE) {
    lengths(x@mz, use.names = use.names)
})
```

And we can now get the peaks count per spectrum:

```{r}
lengths(be)
```


## `isEmpty`

The `isEmpty` method is expected to return for each spectrum the information
whether it is *empty*, i.e. does not contain any MS peaks (and hence m/z or
intensity values). The result of the method has to be a `logical` of length
equal to the number of spectra represented by the backend with `TRUE` indicating
whether a spectrum is empty and `FALSE` otherwise. For our implementation of the
`isEmpty` method we use the `lenghts` method defined above that returns the
number of MS peaks per spectrum.

```{r}
setMethod("isEmpty", "MsBackendTest", function(x) {
    lengths(x) == 0L
})
isEmpty(be)
```


## `tic`

The `tic` method should return the total ion count (i.e. the sum of intensities)
for each spectrum. This information is usually also provided by the raw MS data
files, but can also be calculated on the fly from the data. The parameter
`initial` (which is by default `TRUE`) allows to define whether the provided
*original* tic should be returned (for `initial = TRUE`) or whether the tic
should be calculated on the actual data (`initial = FALSE`). The original tic
values are usually provided by a spectra variable `"totIonCurrent"`. Thus, for
`initial = TRUE`, in our implementation below we return the value of such a
spectra variable it it is avaialble or `NA` if it is not.

```{r}
setMethod("tic", "MsBackendTest", function(object, initial = TRUE) {
    if (initial) {
        if (any(spectraVariables(object) == "totIonCurrent"))
            spectraData(object, "totIonCurrent")[, 1L]
        else rep(NA_real_, length(object))
    } else vapply(intensity(object), sum, numeric(1), na.rm = TRUE)
})
```

We can now either return the original (initial) TIC (which is not available).

```{r}
tic(be)
```

Or calculate the TIC based on the actual intensity values.

```{r}
tic(be, initial = FALSE)
```


### `acquisitionNum`

Extract the `acquisitionNum` core spectra variable. The method is expected to
return an `integer` vector with the same length as there are spectra represented
by the backend. For our backend we simply re-use the `spectraData` method.

```{r}
setMethod("acquisitionNum", "MsBackendTest", function(object) {
    spectraData(object, "acquisitionNum")[, 1L]
})
acquisitionNum(be)
```


### `centroided`

Extract for each spectrum the information whether it contains *centroided*
data. The method is expected to return a `logical` vector with the same length
as there are spectra represented by the backend.

```{r}
setMethod("centroided", "MsBackendTest", function(object) {
    spectraData(object, "centroided")[, 1L]
})
centroided(be)
```


### `collisionEnergy`

Extract for each spectrum the collision energy applied to generate the fragment
spectrum. The method is expected to return a `numeric` vector with the same
length as there are spectra represented by the backend (with `NA_real_` for
spectra for which this information is not available, such as MS1 spectra).

```{r}
setMethod("collisionEnergy", "MsBackendTest", function(object) {
    spectraData(object, "collisionEnergy")[, 1L]
})
collisionEnergy(be)
```


### `dataOrigin`

Extract the *data origin* spectra variable for each spectrum. This spectra
variable can be used to store the origin of each spectra. The method is expected
to return a `character` vector of length equal to the number of spectra
represented by the backend.

```{r}
setMethod("dataOrigin", "MsBackendTest", function(object) {
    spectraData(object, "dataOrigin")[, 1L]
})
dataOrigin(be)
```


### `intensity`

Extract the intensity values for each spectrum in the backend. The result is
expected to be a `NumericList` of length equal to the number of spectra
represented by the backend. For our test backend we can simply return the
`@intensity` slot since the data is already stored within a `NumericList`.

```{r}
setMethod("intensity", "MsBackendTest", function(object) {
    object@intensity
})
intensity(be)
```


### `isolationWindowLowerMz`

Extract the core spectra variable `isolationWindowLowerMz` from the
backend. This information is usually provided for each spectrum in the raw mzML
files. The method is expected to return a `numeric` vector of length equal to
the number of spectra represented by the backend.

```{r}
setMethod("isolationWindowLowerMz", "MsBackendTest", function(object) {
    spectraData(object, "isolationWindowLowerMz")[, 1L]
})
isolationWindowLowerMz(be)
```


### `isolationWindowTargetMz`

Extract the core spectra variable `isolationWindowTargetMz` from the
backend. This information is usually provided for each spectrum in the raw mzML
files. The method is expected to return a `numeric` vector of length equal to
the number of spectra represented by the backend.

```{r}
setMethod("isolationWindowTargetMz", "MsBackendTest", function(object) {
    spectraData(object, "isolationWindowTargetMz")[, 1L]
})
isolationWindowTargetMz(be)
```


### `isolationWindowUpperMz`

Extract the core spectra variable `isolationWindowUpperMz` from the
backend. This information is usually provided for each spectrum in the raw mzML
files. The method is expected to return a `numeric` vector of length equal to
the number of spectra represented by the backend.

```{r}
setMethod("isolationWindowUpperMz", "MsBackendTest", function(object) {
    spectraData(object, "isolationWindowUpperMz")[, 1L]
})
isolationWindowUpperMz(be)
```


### `msLevel`

Extract the MS level for each spectrum in the backend. This method is expected
to return an `integer` of length equal to the number of spectra represented by
the backend.

```{r}
setMethod("msLevel", "MsBackendTest", function(object) {
    spectraData(object, "msLevel")[, 1L]
})
msLevel(be)
```


### `mz`

Extract the m/z values for each spectrum in the backend. The result is
expected to be a `NumericList` of length equal to the number of spectra
represented by the backend. Also, the m/z values are expected to be ordered
increasingly for each element (spectrum).

```{r}
setMethod("mz", "MsBackendTest", function(object) {
    object@mz
})
mz(be)
```


### `polarity`

Extract the `polarity` core spectra variable for each spectrum in the
backend. This method is expected to return an `integer` of length equal to the
number of spectra represented by the backend. Negative and positive polarity are
expected to be encoded by `0L` and `1L`, respectively.

```{r}
setMethod("polarity", "MsBackendTest", function(object) {
    spectraData(object, "polarity")[, 1L]
})
polarity(be)
```


### `precScanNum`

Extract the acquisition number of the precursor for each spectrum. This method
is expected to return an `integer` of length equal to the number of spectra
represented by the backend. For MS1 spectra (or if the acquisition number of the
precursor is not provided) `NA_integer_` has to be returned.

```{r}
setMethod("precScanNum", "MsBackendTest", function(object) {
    spectraData(object, "precScanNum")[, 1L]
})
precScanNum(be)
```


### `precursorCharge`

Extract the charge of the precursor for each spectrum. This method
is expected to return an `integer` of length equal to the number of spectra
represented by the backend. For MS1 spectra (or if the charge of the
precursor is not provided) `NA_integer_` has to be returned.

```{r}
setMethod("precursorCharge", "MsBackendTest", function(object) {
    spectraData(object, "precursorCharge")[, 1L]
})
precursorCharge(be)
```


### `precursorIntensity`

Extract the intensity of the precursor for each spectrum. This method is
expected to return an `numeric` of length equal to the number of spectra
represented by the backend. For MS1 spectra (or if the precursor intensity for a
fragment spectrum is not provided) `NA_real_` has to be returned.

```{r}
setMethod("precursorIntensity", "MsBackendTest", function(object) {
    spectraData(object, "precursorIntensity")[, 1L]
})
precursorIntensity(be)
```


### `precursorMz`

Extract the precursor m/z for each spectrum. This method is
expected to return an `numeric` of length equal to the number of spectra
represented by the backend. For MS1 spectra (or if the precursor m/z for a
fragment spectrum is not provided) `NA_real_` has to be returned.

```{r}
setMethod("precursorMz", "MsBackendTest", function(object) {
    spectraData(object, "precursorMz")[, 1L]
})
precursorMz(be)
```


### `rtime`

Extract the retention time of each spectrum. This method is expected to return a
`numeric` of length equal to the number of spectra represented by the backend.

```{r}
setMethod("rtime", "MsBackendTest", function(object) {
    spectraData(object, "rtime")[, 1L]
})
rtime(be)
```


### `scanIndex`

Extract the *scan index* core spectra variable. The scan index represents the
relative index of the spectrum within the respective raw data file and can be
different than the `acquisitionNum` (which is the index of a spectrum as
recorded by the MS instrument). This method is expected to return a `integer` of
length equal to the number of spectra represented by the backend.

```{r}
setMethod("scanIndex", "MsBackendTest", function(object) {
    spectraData(object, "scanIndex")[, 1L]
})
scanIndex(be)
```


### `smoothed`

Extract the `smoothed` core spectra variable that indicates whether a spectrum
was *smoothed*. This variable is supported for backward compatibility but
seldomly used. The method is expected to return a `logical` with length equal to
the number of spectra represented by the backend.

```{r}
setMethod("smoothed", "MsBackendTest", function(object) {
    spectraData(object, "smoothed")[, 1L]
})
smoothed(be)
```


### `spectraNames`

The `spectraNames` can be used to extract (optional) names (or IDs) for
individual spectra of a backend, or `NULL` if not set. For our test backend we
can use the `rownames` of the `@spectraVars` slot to store spectra names.

```{r}
setMethod("spectraNames", "MsBackendTest", function(object) {
    rownames(object@spectraVars)
})
spectraNames(be)
```

These are all the methods that need to be implemented for a valid *read-only*
`MsBackend` class and running a test on such an object as described in section
*Testing the validity of the backend* should not produce any errors. For
backends that support also data replacement also the methods listed in the next
section need to be implemented.


## Data replacement methods

As stated in the general description, `MsBackend` implementations can also be
purely *read-only* resources allowing to just access data, but not to replace
the data. Thus, it is not strictly required to implement these methods, but for
a fully functional backend it is suggested (as much as possible). A backend for
a purely read-only MS data resource might even extend the `MsBackendCached`
backend defined in the `Spectra` package that provides a mechanism to cache
(spectra variable) data in a `data.frame` within the object. The
`MsBackendMassbankSql` implemented in the `r Biocpkg("MsBackendMassbank")`
package extends for example this backend and thus allows modifying some spectra
variables without changing the original data in the MassBank SQL database.


## Optional methods

Default implementations for these methods are available for `MsBackend`
classes, thus these methods don't have to be implemented for each new
backend. For some backends, depending on how the data is represented or accessed
within it, different implementations might however be more efficient.


### `peaksVariables`

The `peaksVariables` is expected to return a `character` vector with the names
of the *peaks variables* (i.e. information and properties of individual mass
peaks) available in the backend. The default implementation for `MsBackend`
returns by default `c("mz", "intensity")`. This method should only be
implemented for backends that (eventually) also provide additional peaks
variables. The default implementation is shown below.

```{r}
setMethod("peaksVariables", "MsBackend", function(object) {
    c("mz", "intensity")
})
```



## Implementation notes

In this tutorial we implemented a simple *in-memory* `MsBackend` from
scratch. For many real-life situation it might however be better to extend some
of the pre-defined backend classes from the `Spectra` package to avoid
duplicating functionality. A good starting point might be the `MsBackendMemory`
backend for any *in-memory* data representation, or the `MsBackendCached` for
backends that retrieve data from inherently read-only resources (such as
database connection or raw data files) but still would need to support adding
spectra variables or changing values of spectra variables. Similarly, if the
only purpose of a backend is to import or export data in a specific format, the
`MsBackendMemory` might be extended and a single method (`backendInitialize`)
would need to be implemented for the new class: this new `backendInitialize`
would then call the code to import the data from the new file format and store
it within the available slots of the `MsBackendMemory` object. Examples would be
the backends provided by the `r Biocpkg("MsBackendMgf")`
and `r Biocpkg("MsBackendMsp")` classes.


# Testing the validity of the backend

The `Spectra` package provides a set of unit tests that allow to check a backend
for compliance with `MsBackend`. Below we load this test suite and call the
tests. The tests will be performed on a variable `be` in the current workspace
(which in our case is an instance of our `MsBackendTest` class).

```{r, eval = FALSE}
library(testthat)
test_suite <- system.file("test_backends", "test_MsBackend",
                          package = "Spectra")
test_dir(test_suite, stop_on_failure = TRUE)
```


# Session information

```{r si}
sessionInfo()
```

# References


# TEMP all methods to implement

### `export`

### `centroided<-`

### `collisionEnergy<-`

### `dataOrigin<-`

### `dataStorage<-`

### `dropNaSpectraVariables`

### `filterAcquisitionNum`

### `filterDataOrigin`

### `filterDataStorage`

### `filterEmptySpectra`

### `filterIsolationWindow`

### `filterMsLevel`

### `filterPolarity`

### `filterPrecursorMzRange`

### `filterPrecursorMzValues`

### `filterPrecursorCharge`

### `filterPrecursorScan`

### `filterRt`

### `intensity<-`

### `ionCount`

### `isCentroided`

### `isolationWindowLowerMz<-`

### `isolationWindowTargetMz<-`

### `isolationWindowUpperMz<-`

### `isReadOnly`

### `mz<-`

### `polarity<-`

### `peaksData<-`

### `reset`

### `rtime<-`

### `selectSpectraVariables`

### `smoothed<-`

### `spectraData<-`

### `spectraNames<-`

### `split`

### `$<-`

### `[[`

### `[[<-`

### `uniqueMsLevels`
