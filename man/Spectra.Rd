% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Spectra.R
\docType{methods}
\name{Spectra}
\alias{Spectra}
\alias{Spectra-class}
\alias{[,Spectra-method}
\alias{Spectra,DataFrame-method}
\alias{Spectra,missing-method}
\alias{Spectra,MsBackend-method}
\alias{acquisitionNum,Spectra-method}
\alias{centroided,Spectra-method}
\alias{centroided<-,Spectra-method}
\alias{collisionEnergy,Spectra-method}
\alias{collisionEnergy<-,Spectra-method}
\alias{fileNames,Spectra-method}
\alias{fromFile,Spectra-method}
\alias{intensity,Spectra-method}
\alias{ionCount,Spectra-method}
\alias{isCentroided,Spectra-method}
\alias{isEmpty,Spectra-method}
\alias{length,Spectra-method}
\alias{msLevel,Spectra-method}
\alias{mz,Spectra-method}
\alias{peaks,Spectra-method}
\alias{peaksCount,Spectra-method}
\alias{polarity,Spectra-method}
\alias{polarity<-,Spectra-method}
\alias{precScanNum,Spectra-method}
\alias{precursorCharge,Spectra-method}
\alias{precursorIntensity,Spectra-method}
\alias{precursorMz,Spectra-method}
\alias{rtime,Spectra-method}
\alias{rtime<-,Spectra-method}
\alias{scanIndex,Spectra-method}
\alias{selectSpectraVariables,Spectra-method}
\alias{smoothed,Spectra-method}
\alias{smoothed<-,Spectra-method}
\alias{spectraData,Spectra-method}
\alias{spectraData<-,Spectra-method}
\alias{spectraNames,Spectra-method}
\alias{spectraNames<-,Spectra-method}
\alias{spectraVariables,Spectra-method}
\alias{tic,Spectra-method}
\alias{$,Spectra-method}
\alias{$<-,Spectra-method}
\alias{[,Spectra,ANY-method}
\alias{filterAcquisitionNum,Spectra-method}
\alias{filterEmptySpectra,Spectra-method}
\alias{filterFile,Spectra-method}
\alias{filterMsLevel,Spectra-method}
\alias{removePeaks,Spectra-method}
\alias{clean,Spectra-method}
\title{The Spectra class to manage and access MS data}
\usage{
\S4method{Spectra}{DataFrame}(object, processingQueue = list(),
  metadata = list(), ..., backend = MsBackendDataFrame(),
  BPPARAM = bpparam())

\S4method{Spectra}{missing}(object, processingQueue = list(),
  metadata = list(), ..., backend = MsBackendDataFrame(),
  BPPARAM = bpparam())

\S4method{Spectra}{MsBackend}(object, processingQueue = list(),
  metadata = list(), ..., BPPARAM = bpparam())

\S4method{acquisitionNum}{Spectra}(object)

\S4method{centroided}{Spectra}(object)

\S4method{centroided}{Spectra}(object) <- value

\S4method{collisionEnergy}{Spectra}(object)

\S4method{collisionEnergy}{Spectra}(object) <- value

\S4method{fileNames}{Spectra}(object)

\S4method{fromFile}{Spectra}(object)

\S4method{intensity}{Spectra}(object, ...)

\S4method{ionCount}{Spectra}(object)

\S4method{isCentroided}{Spectra}(object, ...)

\S4method{isEmpty}{Spectra}(x)

\S4method{length}{Spectra}(x)

\S4method{msLevel}{Spectra}(object)

\S4method{mz}{Spectra}(object, ...)

\S4method{peaks}{Spectra}(object, ...)

\S4method{peaksCount}{Spectra}(object)

\S4method{polarity}{Spectra}(object)

\S4method{polarity}{Spectra}(object) <- value

\S4method{precScanNum}{Spectra}(object)

\S4method{precursorCharge}{Spectra}(object)

\S4method{precursorIntensity}{Spectra}(object)

\S4method{precursorMz}{Spectra}(object)

\S4method{rtime}{Spectra}(object)

\S4method{rtime}{Spectra}(object) <- value

\S4method{scanIndex}{Spectra}(object)

\S4method{selectSpectraVariables}{Spectra}(object,
  spectraVariables = spectraVariables(object))

\S4method{smoothed}{Spectra}(object)

\S4method{smoothed}{Spectra}(object) <- value

\S4method{spectraData}{Spectra}(object,
  columns = spectraVariables(object))

\S4method{spectraData}{Spectra}(object) <- value

\S4method{spectraNames}{Spectra}(object)

\S4method{spectraNames}{Spectra}(object) <- value

\S4method{spectraVariables}{Spectra}(object)

\S4method{tic}{Spectra}(object, initial = TRUE)

\S4method{$}{Spectra}(x, name)

\S4method{$}{Spectra}(x, name) <- value

\S4method{[}{Spectra,ANY}(x, i, j, ..., drop = FALSE)

\S4method{filterAcquisitionNum}{Spectra}(object, n = integer(),
  file = integer())

\S4method{filterEmptySpectra}{Spectra}(object)

\S4method{filterFile}{Spectra}(object, file = integer())

\S4method{filterMsLevel}{Spectra}(object, msLevel = integer())

\S4method{removePeaks}{Spectra}(object, t = "min",
  msLevel = unique(msLevel(object)))

\S4method{clean}{Spectra}(object, all = FALSE,
  msLevel = unique(msLevel(object)))
}
\arguments{
\item{object}{For \code{Spectra}: either a \code{DataFrame} or \code{missing}. See section
on creation of \code{Spectra} objects for details. For all other methods a
\code{Spectra} object.}

\item{processingQueue}{For \code{Spectra}: optional \code{list} of
\linkS4class{ProcessingStep} objects.}

\item{metadata}{For \code{Spectra}: optional \code{list} with metadata information.}

\item{...}{Additional arguments.}

\item{backend}{For \code{Spectra}: \linkS4class{MsBackend} to be used as backend. See
section on creation of \code{Spectra} objects for details.}

\item{BPPARAM}{Parallel setup configuration. See \code{\link[=bpparam]{bpparam()}} for more
information. This is passed directly to the \code{\link[=backendInitialize]{backendInitialize()}} method
of the \linkS4class{MsBackend}.}

\item{value}{replacement value for \code{<-} methods. See individual
method description or expected data type.}

\item{x}{A \code{Spectra} object.}

\item{spectraVariables}{For \code{selectSpectraVariables}: \code{character} with the
names of the spectra variables to which the backend should be subsetted.}

\item{columns}{For \code{spectraData} accessor: optional \code{character} with column
names (spectra variables) that should be included in the
returned \code{DataFrame}. By default, all columns are returned.}

\item{initial}{For \code{tic}: \code{logical(1)} whether the initially
reported total ion current should be reported, or whether the
total ion current should be (re)calculated on the actual data
(\code{initial = FALSE}, same as \code{ionCount}).}

\item{name}{For \code{$} and \code{$<-}: the name of the spectra variable to return
or set.}

\item{i}{For \code{[}: \code{integer}, \code{logical} or \code{character} to subset the object.}

\item{j}{For \code{[}: not supported.}

\item{drop}{For \code{[}: not considered.}

\item{n}{for \code{filterAcquisitionNum}: \code{integer} with the acquisition numbers
to filter for.}

\item{file}{For \code{filterFile}: index or name of the file(s) to which the data
should be subsetted.}

\item{msLevel}{\code{integer} defining the MS level(s) of the spectra to which
the function should be applied. For \code{filterMsLevel}: the MS level to
which \code{object} should be subsetted.}

\item{t}{for \code{removePeaks}: a \code{numeric(1)} defining the threshold or \code{"min"}.}

\item{all}{for \code{clean}: \code{logical(1)} whether all 0 intensity peaks should be
removed (\code{TRUE}) or whether 0-intensity peaks directly adjacent to a
non-zero intensity peak should be kept (\code{FALSE}).}
}
\value{
See individual method description for the return value.
}
\description{
The \code{Spectra} class encapsules spectral mass spectrometry data and
related metadata.

It supports multiple data backends, e.g. in-memory (\code{\link[=MsBackendDataFrame]{MsBackendDataFrame()}}),
on-disk as mzML (\code{\link[=MsBackendMzR]{MsBackendMzR()}}).
}
\details{
The \code{Spectra} class uses by default a lazy data manipulation strategy,
i.e. data manipulations such as performed with \code{removePeaks} are not applied
immediately to the data, but applied on-the-fly to the spectrum data once it
is retrieved.
}
\section{Creation of objects, conversion and changing the backend}{


\code{Spectra} classes can be created with the \code{Spectra} constructor function
which supports the following formats:
\itemize{
\item parameter \code{object} is a \code{DataFrame} containing the spectrum data. The
provided \code{backend} (by default a \linkS4class{MsBackendDataFrame}) will be
initialized with that data.
\item parameter \code{object} is a \linkS4class{MsBackend} (assumed to be already
initialized).
\item parameter \code{object} is missing, in which case it is supposed that the data
is provided by the \linkS4class{MsBackend} class passed along with the \code{backend}
argument.
}

\code{Spectra} classes are usually created with the \code{readSpectra}
function that reads general spectrum metadata information from the  mass
spectrometry data files.
}

\section{Accessing spectra data}{

\itemize{
\item \code{$}, \code{$<-}: get (or set) a spectra variable for all spectra in \code{object}.
See examples for details.
\item \code{acquisitionNum}: returns the acquisition number of each
spectrum. Returns an \code{integer} of length equal to the number of
spectra (with \code{NA_integer_} if not available).
\item \code{centroided}, \code{centroided<-}: gets or sets the centroiding
information of the spectra. \code{centroided} returns a \code{logical}
vector of length equal to the number of spectra with \code{TRUE} if a
spectrum is centroided, \code{FALSE} if it is in profile mode and \code{NA}
if it is undefined. See also \code{isCentroided} for estimating from
the spectrum data whether the spectrum is centroided.  \code{value}
for \code{centroided<-} is either a single \code{logical} or a \code{logical} of
length equal to the number of spectra in \code{object}.
\item \code{collisionEnergy}, \code{collisionEnergy<-}: gets or sets the
collision energy for all spectra in \code{object}. \code{collisionEnergy}
returns a \code{numeric} with length equal to the number of spectra
(\code{NA_real_} if not present/defined), \code{collisionEnergy<-} takes a
\code{numeric} of length equal to the number of spectra in \code{object}.
\item \code{fileNames}: returns a \code{character} with the file names, or
\code{NA_character_} if not relevant.
\item \code{fromFile}: get the file/sample assignment of each spectrum. Returns an
integer vector of length equal to the number of spectra.
\item \code{intensity}: gets the intensity values from the spectra. Returns
a \code{\link[=SimpleList]{SimpleList()}} of \code{numeric} vectors (intensity values for each
spectrum). The length of the \code{list} is equal to the number of
\code{spectra} in \code{object}.
\item \code{ionCount}: returns a \code{numeric} with the sum of intensities for
each spectrum. If the spectrum is empty (see \code{isEmpty}),
\code{NA_real_} is returned.
\item \code{isCentroided}: a heuristic approach assessing if the spectra in
\code{object} are in profile or centroided mode. The function takes
the \code{qtl}th quantile top peaks, then calculates the difference
between adjacent m/z value and returns \code{TRUE} if the first
quartile is greater than \code{k}. (See \code{Spectra:::.isCentroided} for
the code.)
\item \code{isEmpty}: checks whether a spectrum in \code{object} is empty
(i.e. does not contain any peaks). Returns a \code{logical} vector of
length equal number of spectra.
\item \code{length}: get the number of spectra in the object.
\item \code{msLevel}: get the spectra's MS level. Returns an integer vector (names
being spectrum names, length equal to the number of spectra) with the MS
level for each spectrum.
\item \code{mz}: gets the mass-to-charge ratios (m/z) from the
spectra. Returns a \code{\link[=SimpleList]{SimpleList()}} or length equal to the number of
spectra, each element a \code{numeric} vector with the m/z values of
one spectrum.
\item \code{peaks}: get the \emph{peaks} matrices for all spectra in \code{object}. The function
returns a \code{\link[=SimpleList]{SimpleList()}} of matrices, each \code{matrix} with columns \code{mz} and
\code{intensity} with the m/z and intensity values for all peaks of a spectrum.
\item \code{peaksCount}: gets the number of peaks (m/z-intensity values) per
spectrum. Returns an \code{integer} vector (length equal to the
number of spectra). For empty spectra, \code{NA_integer_} is returned.
\item \code{polarity}, \code{polarity<-}: gets or sets the polarity for each
spectrum.  \code{polarity} returns an \code{integer} vector (length equal
to the number of spectra), with \code{0} and \code{1} representing negative
and positive polarities, respectively. \code{polarity<-} expects an
\code{integer} vector of length 1 or equal to the number of spectra.
\item \code{precursorCharge}, \code{precursorIntensity}, \code{precursorMz},
\code{precScanNum}, \code{precAcquisitionNum}: get the charge (\code{integer}),
intensity (\code{numeric}), m/z (\code{numeric}), scan index (\code{integer})
and acquisition number (\code{interger}) of the precursor for MS level

2 spectra from the object. Returns a vector of length equal to
the number of spectra in \code{object}. \code{NA} are reported for MS1
spectra of if no precursor information is available.
\item \code{rtime}, \code{rtime<-}: gets or sets the retention times for each
spectrum.  \code{rtime} returns a \code{numeric} vector (length equal to
the number of spectra) with the retention time for each spectrum.
\code{rtime<-} expects a numeric vector with length equal to the
number of spectra.
\item \code{scanIndex}: returns an \code{integer} vector with the \emph{scan index}
for each spectrum. This represents the relative index of the
spectrum within each file. Note that this can be different to the
\code{acquisitionNum} of the spectrum which represents the index of the
spectrum during acquisition/measurement (as reported in the mzML file).
\item \code{smoothed},\code{smoothed<-}: gets or sets whether a spectrum is
\emph{smoothed}. \code{smoothed} returns a \code{logical} vector of length equal
to the number of spectra. \code{smoothed<-} takes a \code{logical} vector
of length 1 or equal to the number of spectra in \code{object}.
\item \code{spectraData}, \code{spectraData<-}: get or sets general spectrum
metadata (annotation, also called header). \code{spectraData} returns
a \code{DataFrame}, \code{spectraData<-} expects a \code{DataFrame}. Note that not all
backends support replacing all spectra variables (the \code{\link[=MsBackendMzR]{MsBackendMzR()}}
does for example not allow to replace \code{mz} and \code{intensity} values with the
\code{spectraData<-} method.
\item \code{spectraNames}, \code{spectraNames<-}: get or set the spectra names.
\item \code{spectraVariables}: returns a \code{character} vector with the
available spectra variables (columns, fields or attributes)
available in \code{object}.
\item \code{tic}: gets the total ion current/count (sum of signal of a
spectrum) for all spectra in \code{object}. By default, the value
reported in the original raw data file is returned. For an empty
spectrum, \code{0} is returned.
}
}

\section{Data subsetting and filtering}{


Subseting and filtering of \code{Spectra} objects can be performed with the below
listed methods.
\itemize{
\item \code{[}: subset the spectra keeping only selected elements (\code{i}). The method
\strong{always} returns a \code{Spectra} object.
\item \code{filterAcquisitionNum}: filter the object keeping only spectra matching the
provided acquisition numbers (argument \code{n}). If \code{file} is also provided,
\code{object} is subsetted to the spectra with an acquisition number equal to
\code{n} \strong{in this/these file(s)} and all spectra for the remaining files (not
specified with \code{file}). Returns the filtered \code{Spectra}.
\item \code{filterEmptySpectra}: remove empty spectra (i.e. spectra without peaks).
\item \code{filterFile}: retain data of files matching the file index or file name
provided with parameter \code{file}. Returns the filtered \code{Spectra}.
\item \code{filterMsLevel}: filter object by MS level keeping only spectra matching
the MS level specified with argument \code{msLevel}. Returns the filtered
\code{Spectra}.
\item \code{selectSpectraVariables}: reduce the information within the object to
the selected spectra variables: all data for variables not specified will
be dropped. For mandatory columns (such as \emph{msLevel}, \emph{rtime} ...) only
the values will be dropped, while additional (user defined) spectra
variables will be completely removed. Returns the filtered \code{Spectra}.
}
}

\section{Data manipulation and analysis methods}{


Many data manipulation operations, such as those listed in this section, are
not applied immediately to the spectra, but added to a
\emph{lazy processinq queue}. Operations stored in this queue are applied
on-the-fly to spectra data each time it is accessed. This lazy
execution guarantees the same functionality for \code{Spectra} objects with
any backend, i.e. backends supporting to save changes to spectrum data
(\code{\link[=MsBackendDataFrame]{MsBackendDataFrame()}} as well as read-only backends (such
as the \code{\link[=MsBackendMzR]{MsBackendMzR()}}).
\itemize{
\item \code{clean}: remove 0-intensity data points. For \code{all = FALSE} (the default)
0-intensity peaks next to non-zero intensity peaks are retained while with
\code{all = TRUE} all 0-intensity peaks are removed.
\item \code{removePeaks}: \emph{remove} peaks lower or equal to a threshold intensity
value \code{t} by setting their intensity to \code{0}. With the default \code{t = "min"}
all peaks with an intensity smaller or equal to the minimal non-zero
intensity is set to \code{0}. If the spectrum is in profile mode, ranges of
successive non-0 peaks <= \code{t} are set to 0. If the spectrum is centroided,
then individual peaks <= \code{t} are set to 0. Note that the number of peaks
is not changed unless \code{clean} is called after \code{removePeaks}.
}
}

\examples{

## Create a Spectra providing a `DataFrame` containing the spectrum data.

spd <- DataFrame(msLevel = c(1L, 2L), rtime = c(1.1, 1.2))
spd$mz <- list(c(100, 103.2, 104.3, 106.5), c(45.6, 120.4, 190.2))
spd$intensity <- list(c(200, 400, 34.2, 17), c(12.3, 15.2, 6.8))

data <- Spectra(spd)
data

## ---- ACCESSING AND ADDING DATA ----

## Get the MS level for each spectrum.
msLevel(data)

## Alternatively, we could also use $ to access a specific spectra variable.
## This could also be used to add additional spectra variables to the
## object (see further below).
data$msLevel

## Get the intensity and m/z values.
intensity(data)
mz(data)

## Get the m/z for the first spectrum.
mz(data)[[1]]

## Get the peak data (m/z and intensity values).
pks <- peaks(data)
pks
pks[[1]]
pks[[2]]

## List all available spectra variables (i.e. spectrum data and metadata).
spectraVariables(data)

## For all *core* spectrum variables accessor functions are available. These
## return NA if the variable was not set.
centroided(data)
fromFile(data)
rtime(data)
precursorMz(data)

## Add an additional metadata column.
data$spectrum_id <- c("sp_1", "sp_2")

## List spectra variables.
spectraVariables(data)

## Get the values for the new spectra variable
data$spectrum_id

## Extract specific spectra variables.
spectraData(data, columns = c("spectrum_id", "msLevel"))

## Drop spectra variable data and/or columns.
res <- selectSpectraVariables(data, c("mz", "intensity"))

## This removed the additional columns "spectrum_id" and deleted all values
## for all spectra variables, except "mz" and "intensity".
spectraData(res)

## Compared to the data before selectSpectraVariables.
spectraData(data)


## ---- SUBSETTING AND FILTERING

## Subset to all MS2 spectra.
data[msLevel(data) == 2]

## Same with the filterMsLevel function
filterMsLevel(data, 2)

## ---- DATA MANIPULATIONS ----

## Set the data to be centroided
centroided(data) <- TRUE

## Remove peaks with an intensity below 40.
res <- removePeaks(data, t = 40)
res

## Get the intensities of the first and second spectrum.
intensity(res)[[1]]
intensity(res)[[2]]

## Clean all spectra removing all 0-intensity peaks.
res <- clean(res, all = TRUE)

## Get the intensities of the first and second spectrum.
intensity(res)[[1]]
intensity(res)[[2]]

## Second spectrum is now empty:
isEmpty(res)
}
\author{
Sebastian Gibb, Johannes Rainer
}
