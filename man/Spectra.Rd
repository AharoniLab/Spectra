% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Spectra.R
\docType{methods}
\name{Spectra}
\alias{Spectra}
\alias{Spectra-class}
\alias{Spectra,DataFrame-method}
\alias{Spectra,missing-method}
\alias{Spectra,MsBackend-method}
\alias{acquisitionNum,Spectra-method}
\alias{centroided,Spectra-method}
\alias{centroided<-,Spectra-method}
\alias{collisionEnergy,Spectra-method}
\alias{collisionEnergy<-,Spectra-method}
\alias{fileNames,Spectra-method}
\alias{fromFile,Spectra-method}
\alias{intensity,Spectra-method}
\alias{ionCount,Spectra-method}
\alias{isCentroided,Spectra-method}
\alias{isEmpty,Spectra-method}
\alias{length,Spectra-method}
\alias{msLevel,Spectra-method}
\alias{mz,Spectra-method}
\alias{peaks,Spectra-method}
\alias{peaksCount,Spectra-method}
\alias{polarity,Spectra-method}
\alias{polarity<-,Spectra-method}
\alias{precScanNum,Spectra-method}
\alias{precursorCharge,Spectra-method}
\alias{precursorIntensity,Spectra-method}
\alias{precursorMz,Spectra-method}
\alias{rtime,Spectra-method}
\alias{rtime<-,Spectra-method}
\alias{scanIndex,Spectra-method}
\alias{selectSpectraVariables,Spectra-method}
\alias{smoothed,Spectra-method}
\alias{smoothed<-,Spectra-method}
\alias{spectraData,Spectra-method}
\alias{spectraData<-,Spectra-method}
\alias{spectraNames,Spectra-method}
\alias{spectraNames<-,Spectra-method}
\alias{spectraVariables,Spectra-method}
\alias{tic,Spectra-method}
\alias{[,Spectra-method}
\alias{removePeaks,Spectra-method}
\alias{clean,Spectra-method}
\title{The Spectra class to manage and access MS data}
\usage{
\S4method{Spectra}{DataFrame}(object, processingQueue = list(),
  metadata = list(), ..., backend = MsBackendDataFrame(),
  BPPARAM = bpparam())

\S4method{Spectra}{missing}(object, processingQueue = list(),
  metadata = list(), ..., backend = MsBackendDataFrame(),
  BPPARAM = bpparam())

\S4method{Spectra}{MsBackend}(object, processingQueue = list(),
  metadata = list(), ..., BPPARAM = bpparam())

\S4method{acquisitionNum}{Spectra}(object)

\S4method{centroided}{Spectra}(object)

\S4method{centroided}{Spectra}(object) <- value

\S4method{collisionEnergy}{Spectra}(object)

\S4method{collisionEnergy}{Spectra}(object) <- value

\S4method{fileNames}{Spectra}(object)

\S4method{fromFile}{Spectra}(object)

\S4method{intensity}{Spectra}(object, ...)

\S4method{ionCount}{Spectra}(object)

\S4method{isCentroided}{Spectra}(object, ...)

\S4method{isEmpty}{Spectra}(x)

\S4method{length}{Spectra}(x)

\S4method{msLevel}{Spectra}(object)

\S4method{mz}{Spectra}(object, ...)

\S4method{peaks}{Spectra}(object, ...)

\S4method{peaksCount}{Spectra}(object)

\S4method{polarity}{Spectra}(object)

\S4method{polarity}{Spectra}(object) <- value

\S4method{precScanNum}{Spectra}(object)

\S4method{precursorCharge}{Spectra}(object)

\S4method{precursorIntensity}{Spectra}(object)

\S4method{precursorMz}{Spectra}(object)

\S4method{rtime}{Spectra}(object)

\S4method{rtime}{Spectra}(object) <- value

\S4method{scanIndex}{Spectra}(object)

\S4method{selectSpectraVariables}{Spectra}(object,
  spectraVariables = spectraVariables(object))

\S4method{smoothed}{Spectra}(object)

\S4method{smoothed}{Spectra}(object) <- value

\S4method{spectraData}{Spectra}(object,
  columns = spectraVariables(object))

\S4method{spectraData}{Spectra}(object) <- value

\S4method{spectraNames}{Spectra}(object)

\S4method{spectraNames}{Spectra}(object) <- value

\S4method{spectraVariables}{Spectra}(object)

\S4method{tic}{Spectra}(object, initial = TRUE)

\S4method{[}{Spectra}(x, i, j, ..., drop = FALSE)

\S4method{removePeaks}{Spectra}(object, t = "min", msLevel.)

\S4method{clean}{Spectra}(object, all = FALSE, msLevel.)
}
\arguments{
\item{object}{For \code{Spectra}: either a \code{DataFrame} or \code{missing}. See section
on creation of \code{Spectra} objects for details. For all other methods a
\code{Spectra} object.}

\item{processingQueue}{For \code{Spectra}: optional \code{list} of
\linkS4class{ProcessingStep} objects.}

\item{metadata}{For \code{Spectra}: optional \code{list} with metadata information.}

\item{...}{Additional arguments.}

\item{backend}{For \code{Spectra}: \linkS4class{MsBackend} to be used as backend. See
section on creation of \code{Spectra} objects for details.}

\item{BPPARAM}{Parallel setup configuration. See \code{\link[=bpparam]{bpparam()}} for more
information. This is passed directly to the \code{\link[=backendInitialize]{backendInitialize()}} method
of the \linkS4class{MsBackend}.}

\item{value}{replacement value for \code{<-} methods. See individual
method description or expected data type.}

\item{x}{A \code{Spectra} object.}

\item{spectraVariables}{For \code{selectSpectraVariables}: \code{character} with the
names of the spectra variables to which the backend should be subsetted.}

\item{columns}{For \code{spectraData} accessor: optional \code{character} with column
names (spectra variables) that should be included in the
returned \code{DataFrame}. By default, all columns are returned.}

\item{t}{for \code{removePeaks}: a \code{numeric(1)} defining the threshold or \code{"min"}.}

\item{msLevel.}{\code{integer} defining the MS level(s) of the spectra to which
the function should be applied. For \code{filterMsLevel}: the MS level to
which \code{object} should be subsetted.}

\item{all}{for \code{clean}: \code{logical(1)} whether all 0 intensity peaks should be
removed (\code{TRUE}) or whether 0-intensity peaks directly adjacent to a
non-zero intensity peak should be kept (\code{FALSE}).}
}
\value{
See individual method description for the return value.
}
\description{
The \code{Spectra} class encapsules spectral mass spectrometry data and
related metadata.

It supports multiple data backends, e.g. in-memory (\code{\link[=MsBackendDataFrame]{MsBackendDataFrame()}}),
on-disk as mzML (\code{\link[=MsBackendMzR]{MsBackendMzR()}}).
}
\details{
The \code{Spectra} class uses by default a lazy data manipulation strategy,
i.e. data manipulations such as performed with \code{removePeaks} are not applied
immediately to the data, but applied on-the-fly to the spectrum data once it
is retrieved.
}
\section{Creation of objects, conversion and changing the backend}{


\code{Spectra} classes can be created with the \code{Spectra} constructor function
which supports the following formats:
\itemize{
\item parameter \code{object} is a \code{DataFrame} containing the spectrum data. The
provided \code{backend} (by default a \linkS4class{MsBackendDataFrame}) will be
initialized with that data.
\item parameter \code{object} is a \linkS4class{MsBackend} (assumed to be already
initialized).
\item parameter \code{object} is missing, in which case it is supposed that the data
is provided by the \linkS4class{MsBackend} class passed along with the \code{backend}
argument.
}

\code{Spectra} classes are usually created with the \code{readSpectra}
function that reads general spectrum metadata information from the  mass
spectrometry data files.
}

\section{Accessing spectra data}{

\itemize{
\item \code{acquisitionNum}: returns the acquisition number of each
spectrum. Returns an \code{integer} of length equal to the number of
spectra (with \code{NA_integer_} if not available).
\item \code{centroided}, \code{centroided<-}: gets or sets the centroiding
information of the spectra. \code{centroided} returns a \code{logical}
vector of length equal to the number of spectra with \code{TRUE} if a
spectrum is centroided, \code{FALSE} if it is in profile mode and \code{NA}
if it is undefined. See also \code{isCentroided} for estimating from
the spectrum data whether the spectrum is centroided.  \code{value}
for \code{centroided<-} is either a single \code{logical} or a \code{logical} of
length equal to the number of spectra in \code{object}.
\item \code{collisionEnergy}, \code{collisionEnergy<-}: gets or sets the
collision energy for all spectra in \code{object}. \code{collisionEnergy}
returns a \code{numeric} with length equal to the number of spectra
(\code{NA_real_} if not present/defined), \code{collisionEnergy<-} takes a
\code{numeric} of length equal to the number of spectra in \code{object}.
\item \code{fileNames}: returns a \code{character} with the file names, or
\code{NA_character_} if not relevant.
\item \code{fromFile}: get the file/sample assignment of each spectrum. Returns an
integer vector of length equal to the number of spectra.
\item \code{intensity}: gets the intensity values from the spectra. Returns
a \code{\link[=SimpleList]{SimpleList()}} of \code{numeric} vectors (intensity values for each
spectrum). The length of the \code{list} is equal to the number of
\code{spectra} in \code{object}.
\item \code{ionCount}: returns a \code{numeric} with the sum of intensities for
each spectrum. If the spectrum is empty (see \code{isEmpty}),
\code{NA_real_} is returned.
\item \code{isCentroided}: a heuristic approach assessing if the spectra in
\code{object} are in profile or centroided mode. The function takes
the \code{qtl}th quantile top peaks, then calculates the difference
between adjacent m/z value and returns \code{TRUE} if the first
quartile is greater than \code{k}. (See \code{Spectra:::.isCentroided} for
the code.)
\item \code{isEmpty}: checks whether a spectrum in \code{object} is empty
(i.e. does not contain any peaks). Returns a \code{logical} vector of
length equal number of spectra.
\item \code{length}: get the number of spectra in the object.
\item \code{msLevel}: get the spectra's MS level. Returns an integer vector (names
being spectrum names, length equal to the number of spectra) with the MS
level for each spectrum.
\item \code{mz}: gets the mass-to-charge ratios (m/z) from the
spectra. Returns a \code{\link[=SimpleList]{SimpleList()}} or length equal to the number of
spectra, each element a \code{numeric} vector with the m/z values of
one spectrum.
\item \code{peaks}: get the \emph{peaks} matrices for all spectra in \code{object}. The function
returns a \code{\link[=SimpleList]{SimpleList()}} of matrices, each \code{matrix} with columns \code{mz} and
\code{intensity} with the m/z and intensity values for all peaks of a spectrum.
\item \code{peaksCount}: gets the number of peaks (m/z-intensity values) per
spectrum. Returns an \code{integer} vector (length equal to the
number of spectra). For empty spectra, \code{NA_integer_} is returned.
\item \code{selectSpectraVariables}: reduce the information within the object to
the selected spectra variables.
\item \code{smoothed},\code{smoothed<-}: geta or sets whether a spectrum is
\emph{smoothed}. \code{smoothed} returns a \code{logical} vector of length equal
to the number of spectra. \code{smoothed<-} takes a \code{logical} vector
of length 1 or equal to the number of spectra in \code{object}.
\item \code{spectraData}, \code{spectraData<-}: get or sets general spectrum
metadata (annotation, also called header). \code{spectraData} returns
a \code{DataFrame}, \code{spectraData<-} expects a \code{DataFrame}.
\item \code{spectraNames}: returns a \code{character} vector with the names of
the spectra in \code{object}.
\item \code{spectraVariables}: returns a \code{character} vector with the
available spectra variables (columns, fields or attributes)
available in \code{object}.
}
}

\section{Data manipulation and analysis methods}{


Many data manipulation operations, such as those listed in this section, are
not applied immediately to the spectra, but added to a
\emph{lazy processinq queue}. Operations stored in this queue are applied
on-the-fly to spectra data each time it is accessed. This lazy
execution guarantees the same functionality for \code{Spectra} objects with
any backend, i.e. backends supporting to save changes to spectrum data
(\code{\link[=MsBackendDataFrame]{MsBackendDataFrame()}} as well as read-only backends (such
as the \code{\link[=MsBackendMzR]{MsBackendMzR()}}).
\itemize{
\item \code{clean}: remove 0-intensity data points. For \code{all = FALSE} (the default)
0-intensity peaks next to non-zero intensity peaks are retained while with
\code{all = TRUE} all 0-intensity peaks are removed.
\item \code{removePeaks}: \emph{remove} peaks lower or equal to a threshold intensity
value \code{t} by setting their intensity to \code{0}. With the default \code{t = "min"}
all peaks with an intensity smaller or equal to the minimal non-zero
intensity is set to \code{0}. If the spectrum is in profile mode, ranges of
successive non-0 peaks <= \code{t} are set to 0. If the spectrum is centroided,
then individual peaks <= \code{t} are set to 0. Note that the number of peaks
is not changed unless \code{clean} is called after \code{removePeaks}.
}
}

\examples{

## Create a Spectra providing a `DataFrame` containing the spectrum data.

spd <- DataFrame(msLevel = c(1L, 2L), rtime = c(1.1, 1.2))
spd$mz <- list(c(100, 103.2, 104.3, 106.5), c(45.6, 120.4, 190.2))
spd$intensity <- list(c(200, 400, 34.2, 17), c(12.3, 15.2, 6.8))

data <- Spectra(spd)
data

## ---- ACCESSING AND ADDING DATA ----

## Get the MS level for each spectrum.
msLevel(data)

## Get the intensity and m/z values.
intensity(data)
mz(data)

## Get the peak data (m/z and intensity values).
pks <- peaks(data)
pks
pks[[1]]
pks[[2]]

## List all available spectra variables (i.e. spectrum data and metadata).
spectraVariables(data)

## For all *core* spectrum variables accessor functions are available.
centroided(data)
## fromFile(data)
## rtime(data)
## precursorMz(data)

## Add an additional metadata column.
## spectraData(data)$spectrum_id <- c("sp_1", "sp_2")

## List spectra variables.
## spectraVariables(data)

## Extract specific spectra variables.
## spectraData(data, columns = c("spectrum_id", "msLevel"))

## ---- DATA MANIPULATIONS ----
}
\author{
Sebastian Gibb, Johannes Rainer
}
