% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Spectra-functions.R, R/Spectra.R
\docType{methods}
\name{addProcessing}
\alias{addProcessing}
\alias{applyProcessing}
\alias{Spectra}
\alias{Spectra-class}
\alias{[,Spectra-method}
\alias{Spectra,DataFrame-method}
\alias{Spectra,missing-method}
\alias{Spectra,MsBackend-method}
\alias{Spectra,character-method}
\alias{setBackend,Spectra,MsBackend-method}
\alias{c,Spectra-method}
\alias{acquisitionNum,Spectra-method}
\alias{centroided,Spectra-method}
\alias{centroided<-,Spectra-method}
\alias{collisionEnergy,Spectra-method}
\alias{collisionEnergy<-,Spectra-method}
\alias{dataOrigin,Spectra-method}
\alias{dataOrigin<-,Spectra-method}
\alias{dataStorage,Spectra-method}
\alias{intensity,Spectra-method}
\alias{ionCount,Spectra-method}
\alias{isCentroided,Spectra-method}
\alias{isEmpty,Spectra-method}
\alias{isolationWindowLowerMz,Spectra-method}
\alias{isolationWindowLowerMz<-,Spectra-method}
\alias{isolationWindowTargetMz,Spectra-method}
\alias{isolationWindowTargetMz<-,Spectra-method}
\alias{isolationWindowUpperMz,Spectra-method}
\alias{isolationWindowUpperMz<-,Spectra-method}
\alias{length,Spectra-method}
\alias{msLevel,Spectra-method}
\alias{mz,Spectra-method}
\alias{peaks,Spectra-method}
\alias{peaksCount,Spectra-method}
\alias{polarity,Spectra-method}
\alias{polarity<-,Spectra-method}
\alias{precScanNum,Spectra-method}
\alias{precursorCharge,Spectra-method}
\alias{precursorIntensity,Spectra-method}
\alias{precursorMz,Spectra-method}
\alias{rtime,Spectra-method}
\alias{rtime<-,Spectra-method}
\alias{scanIndex,Spectra-method}
\alias{selectSpectraVariables,Spectra-method}
\alias{smoothed,Spectra-method}
\alias{smoothed<-,Spectra-method}
\alias{spectraData,Spectra-method}
\alias{spectraData<-,Spectra-method}
\alias{spectraNames,Spectra-method}
\alias{spectraNames<-,Spectra-method}
\alias{spectraVariables,Spectra-method}
\alias{tic,Spectra-method}
\alias{$,Spectra-method}
\alias{$<-,Spectra-method}
\alias{filterAcquisitionNum,Spectra-method}
\alias{filterEmptySpectra,Spectra-method}
\alias{filterDataOrigin,Spectra-method}
\alias{filterDataStorage,Spectra-method}
\alias{filterIsolationWindow,Spectra-method}
\alias{filterMsLevel,Spectra-method}
\alias{filterPolarity,Spectra-method}
\alias{filterPrecursorMz,Spectra-method}
\alias{filterPrecursorScan,Spectra-method}
\alias{filterRt,Spectra-method}
\alias{bin,Spectra-method}
\alias{clean,Spectra-method}
\alias{removePeaks,Spectra-method}
\title{The Spectra class to manage and access MS data}
\usage{
addProcessing(object, FUN, ...)

applyProcessing(object, f = dataStorage(object), BPPARAM = bpparam(),
  ...)

\S4method{Spectra}{DataFrame}(object, processingQueue = list(),
  metadata = list(), ..., backend = MsBackendDataFrame(),
  BPPARAM = bpparam())

\S4method{Spectra}{missing}(object, processingQueue = list(),
  metadata = list(), ..., backend = MsBackendDataFrame(),
  BPPARAM = bpparam())

\S4method{Spectra}{MsBackend}(object, processingQueue = list(),
  metadata = list(), ..., BPPARAM = bpparam())

\S4method{Spectra}{character}(object, processingQueue = list(),
  metadata = list(), source = MsBackendMzR(),
  backend = MsBackendDataFrame(), ..., BPPARAM = bpparam())

\S4method{setBackend}{Spectra,MsBackend}(object, backend,
  f = dataStorage(object), ..., BPPARAM = bpparam())

\S4method{c}{Spectra}(x, ...)

\S4method{acquisitionNum}{Spectra}(object)

\S4method{centroided}{Spectra}(object)

\S4method{centroided}{Spectra}(object) <- value

\S4method{collisionEnergy}{Spectra}(object)

\S4method{collisionEnergy}{Spectra}(object) <- value

\S4method{dataOrigin}{Spectra}(object)

\S4method{dataOrigin}{Spectra}(object) <- value

\S4method{dataStorage}{Spectra}(object)

\S4method{intensity}{Spectra}(object, ...)

\S4method{ionCount}{Spectra}(object)

\S4method{isCentroided}{Spectra}(object, ...)

\S4method{isEmpty}{Spectra}(x)

\S4method{isolationWindowLowerMz}{Spectra}(object)

\S4method{isolationWindowLowerMz}{Spectra}(object) <- value

\S4method{isolationWindowTargetMz}{Spectra}(object)

\S4method{isolationWindowTargetMz}{Spectra}(object) <- value

\S4method{isolationWindowUpperMz}{Spectra}(object)

\S4method{isolationWindowUpperMz}{Spectra}(object) <- value

\S4method{length}{Spectra}(x)

\S4method{msLevel}{Spectra}(object)

\S4method{mz}{Spectra}(object, ...)

\S4method{peaks}{Spectra}(object, ...)

\S4method{peaksCount}{Spectra}(object)

\S4method{polarity}{Spectra}(object)

\S4method{polarity}{Spectra}(object) <- value

\S4method{precScanNum}{Spectra}(object)

\S4method{precursorCharge}{Spectra}(object)

\S4method{precursorIntensity}{Spectra}(object)

\S4method{precursorMz}{Spectra}(object)

\S4method{rtime}{Spectra}(object)

\S4method{rtime}{Spectra}(object) <- value

\S4method{scanIndex}{Spectra}(object)

\S4method{selectSpectraVariables}{Spectra}(object,
  spectraVariables = spectraVariables(object))

\S4method{smoothed}{Spectra}(object)

\S4method{smoothed}{Spectra}(object) <- value

\S4method{spectraData}{Spectra}(object,
  columns = spectraVariables(object))

\S4method{spectraData}{Spectra}(object) <- value

\S4method{spectraNames}{Spectra}(object)

\S4method{spectraNames}{Spectra}(object) <- value

\S4method{spectraVariables}{Spectra}(object)

\S4method{tic}{Spectra}(object, initial = TRUE)

\S4method{$}{Spectra}(x, name)

\S4method{$}{Spectra}(x, name) <- value

\S4method{[}{Spectra}(x, i, j, ..., drop = FALSE)

\S4method{filterAcquisitionNum}{Spectra}(object, n = integer(),
  dataStorage = character(), dataOrigin = character())

\S4method{filterEmptySpectra}{Spectra}(object)

\S4method{filterDataOrigin}{Spectra}(object, dataOrigin = character())

\S4method{filterDataStorage}{Spectra}(object, dataStorage = character())

\S4method{filterIsolationWindow}{Spectra}(object, mz = numeric())

\S4method{filterMsLevel}{Spectra}(object, msLevel. = integer())

\S4method{filterPolarity}{Spectra}(object, polarity = integer())

\S4method{filterPrecursorMz}{Spectra}(object, mz = numeric(), ppm = 0)

\S4method{filterPrecursorScan}{Spectra}(object,
  acquisitionNum = integer())

\S4method{filterRt}{Spectra}(object, rt = numeric(),
  msLevel. = unique(msLevel(object)))

\S4method{bin}{Spectra}(object, binSize = 1L, breaks = NULL,
  msLevel. = unique(msLevel(object)))

\S4method{clean}{Spectra}(object, all = FALSE,
  msLevel. = unique(msLevel(object)))

\S4method{removePeaks}{Spectra}(object, t = "min",
  msLevel. = unique(msLevel(object)))
}
\arguments{
\item{object}{For \code{Spectra}: either a \code{DataFrame} or \code{missing}. See section
on creation of \code{Spectra} objects for details. For all other methods a
\code{Spectra} object.}

\item{FUN}{For \code{addProcessing}: function to be applied to the peak matrix
of each spectrum in \code{object}. See section \emph{Data manipulations} below
for more details.}

\item{...}{Additional arguments.}

\item{f}{For \code{setBackend}: factor defining how to split the data for
parallelized copying of the spectra data to the new backend. For some
backends changing this parameter can lead to errors.}

\item{BPPARAM}{Parallel setup configuration. See \code{\link[=bpparam]{bpparam()}} for more
information. This is passed directly to the \code{\link[=backendInitialize]{backendInitialize()}} method
of the \linkS4class{MsBackend}.}

\item{processingQueue}{For \code{Spectra}: optional \code{list} of
\linkS4class{ProcessingStep} objects.}

\item{metadata}{For \code{Spectra}: optional \code{list} with metadata information.}

\item{backend}{For \code{Spectra}: \linkS4class{MsBackend} to be used as backend. See
section on creation of \code{Spectra} objects for details. For \code{setBackend}:
instance of \linkS4class{MsBackend}. See section on creation of \code{Spectra}
objects for details.}

\item{source}{For \code{Spectra}: instance of \linkS4class{MsBackend} that can be used
to import spectrum data from the provided files. See section \emph{Creation
of objects, conversion and changing the backend} for more details.}

\item{x}{A \code{Spectra} object.}

\item{value}{replacement value for \code{<-} methods. See individual
method description or expected data type.}

\item{spectraVariables}{For \code{selectSpectraVariables}: \code{character} with the
names of the spectra variables to which the backend should be subsetted.}

\item{columns}{For \code{spectraData} accessor: optional \code{character} with column
names (spectra variables) that should be included in the
returned \code{DataFrame}. By default, all columns are returned.}

\item{initial}{For \code{tic}: \code{logical(1)} whether the initially
reported total ion current should be reported, or whether the
total ion current should be (re)calculated on the actual data
(\code{initial = FALSE}, same as \code{ionCount}).}

\item{name}{For \code{$} and \code{$<-}: the name of the spectra variable to return
or set.}

\item{i}{For \code{[}: \code{integer}, \code{logical} or \code{character} to subset the object.}

\item{j}{For \code{[}: not supported.}

\item{drop}{For \code{[}: not considered.}

\item{n}{for \code{filterAcquisitionNum}: \code{integer} with the acquisition numbers
to filter for.}

\item{dataStorage}{For \code{filterDataStorage}: \code{character} to define which
spectra to keep.
For \code{filterAcquisitionNum}: optionally specify if filtering should occur
only for spectra of selected \code{dataStorage}.}

\item{dataOrigin}{For \code{filterDataOrigin}: \code{character} to define which
spectra to keep.
For \code{filterAcquisitionNum}: optionally specify if filtering should occurr
only for spectra of selected \code{dataOrigin}.}

\item{mz}{For \code{filterIsolationWindow} and \code{filterPrecursorMz}: \code{numeric(1)}
with the m/z value to filter the object.}

\item{msLevel.}{\code{integer} defining the MS level(s) of the spectra to which
the function should be applied. For \code{filterMsLevel}: the MS level to
which \code{object} should be subsetted.}

\item{polarity}{for \code{filterPolarity}: \code{integer} specifying the polarity to
to subset \code{object}.}

\item{ppm}{For \code{filterPrecursorMz}: \code{numeric(1)} defining the accepted
difference between the provided m/z and the spectrum's m/z in parts per
million.}

\item{acquisitionNum}{for \code{filterPrecursorScan}: \code{integer} with the
acquisition number of the spectra to which the object should be
subsetted.}

\item{rt}{for \code{filterRt}: \code{numeric(2)} defining the retention time range to
be used to subset/filter \code{object}.}

\item{binSize}{For \code{bin}: \code{numeric(1)} defining the size for the m/z bins.
Defaults to \code{binSize = 1}.}

\item{breaks}{For \code{bin}: \code{numeric} defining the m/z breakpoints between bins.}

\item{all}{for \code{clean}: \code{logical(1)} whether all 0 intensity peaks should be
removed (\code{TRUE}) or whether 0-intensity peaks directly adjacent to a
non-zero intensity peak should be kept (\code{FALSE}).}

\item{t}{for \code{removePeaks}: a \code{numeric(1)} defining the threshold or \code{"min"}.}

\item{msLevel}{For \code{filterMsLevel}: the MS level to which \code{object} should be
subsetted.}
}
\value{
See individual method description for the return value.
}
\description{
The \code{Spectra} class encapsules spectral mass spectrometry data and
related metadata.

It supports multiple data backends, e.g. in-memory (\code{\link[=MsBackendDataFrame]{MsBackendDataFrame()}}),
on-disk as mzML (\code{\link[=MsBackendMzR]{MsBackendMzR()}}) or HDF5 (\code{\link[=MsBackendHdf5Peaks]{MsBackendHdf5Peaks()}}).
}
\details{
The \code{Spectra} class uses by default a lazy data manipulation strategy,
i.e. data manipulations such as performed with \code{removePeaks} are not applied
immediately to the data, but applied on-the-fly to the spectrum data once it
is retrieved. For some backends that allow to write data back to the data
storage (such as the \code{\link[=MsBackendDataFrame]{MsBackendDataFrame()}} and \code{\link[=MsBackendHdf5Peaks]{MsBackendHdf5Peaks()}}) it
is possible to apply to queue with the \code{applyProcessing} function. See the
\emph{Data manipulation and analysis methods} section below for more details.
}
\section{Creation of objects, conversion and changing the backend}{


\code{Spectra} classes can be created with the \code{Spectra} constructor function
which supports the following formats:
\itemize{
\item parameter \code{object} is a \code{DataFrame} containing the spectrum data. The
provided \code{backend} (by default a \linkS4class{MsBackendDataFrame}) will be
initialized with that data.
\item parameter \code{object} is a \linkS4class{MsBackend} (assumed to be already
initialized).
\item parameter \code{object} is missing, in which case it is supposed that the data
is provided by the \linkS4class{MsBackend} class passed along with the \code{backend}
argument.
\item parameter \code{object} is of type \code{character} and is expected to be the file
names(s) from which spectra should be imported. Parameter \code{source} allows
to define a \linkS4class{MsBackend} that is able to import the data from the
provided source files. The default value for \code{source} is \code{\link[=MsBackendMzR]{MsBackendMzR()}}
which allows to import spectra data from mzML, mzXML or CDF files.
}

With \code{...} additional arguments can be passed to the backend's
\code{\link[=backendInitialize]{backendInitialize()}} method. Parameter \code{backend} allows to specify which
\linkS4class{MsBackend} should be used for data storage.

The backend of a \code{Spectra} object can be changed with the \code{setBackend}
method that takes an instance of the new backend as second parameter
\code{backend}. A call to \code{setBackend(sps, backend = MsBackendDataFrame())} would
for example change the backend or \code{sps} to the \emph{in-memory}
\code{MsBackendDataFrame}. Note that it is not possible to change the backend
to a \emph{read-only} backend (such as the \code{\link[=MsBackendMzR]{MsBackendMzR()}} backend). \code{setBackend}
changes the \code{"dataOrigin"} variable of the resulting \code{Spectra} object to the
\code{"dataStorage"} variable of the backend before the switch.

The definition of the function is:
\code{setBackend(object, backend, ..., f = dataStorage(object), BPPARAM = bpparam())}
and its parameters are:
\itemize{
\item parameter \code{object}: the \code{Spectra} object.
\item parameter \code{backend}: an instance of the new backend, e.g.
\code{MsBackendDataFrame()}.
\item parameter \code{f}: factor allowing to parallelize the change of the backends.
By default the process of copying the spectra data from the original to the
new backend is performed separately (and in parallel) for each file. Users
are advised to use the default setting.
\item parameter \code{...}: optional additional arguments passed to the
\code{\link[=backendInitialize]{backendInitialize()}} method of the new \code{backend}.
\item parameter \code{BPPARAM}: setup for the parallel processing. See \code{\link[=bpparam]{bpparam()}} for
details.
}
}

\section{Accessing spectra data}{

\itemize{
\item \code{$}, \code{$<-}: gets (or sets) a spectra variable for all spectra in \code{object}.
See examples for details.
\item \code{acquisitionNum}: returns the acquisition number of each
spectrum. Returns an \code{integer} of length equal to the number of
spectra (with \code{NA_integer_} if not available).
\item \code{centroided}, \code{centroided<-}: gets or sets the centroiding
information of the spectra. \code{centroided} returns a \code{logical}
vector of length equal to the number of spectra with \code{TRUE} if a
spectrum is centroided, \code{FALSE} if it is in profile mode and \code{NA}
if it is undefined. See also \code{isCentroided} for estimating from
the spectrum data whether the spectrum is centroided.  \code{value}
for \code{centroided<-} is either a single \code{logical} or a \code{logical} of
length equal to the number of spectra in \code{object}.
\item \code{collisionEnergy}, \code{collisionEnergy<-}: gets or sets the
collision energy for all spectra in \code{object}. \code{collisionEnergy}
returns a \code{numeric} with length equal to the number of spectra
(\code{NA_real_} if not present/defined), \code{collisionEnergy<-} takes a
\code{numeric} of length equal to the number of spectra in \code{object}.
\item \code{dataOrigin}, \code{dataOrigin<-}: gets or sets the \emph{data origin} for each
spectrum. \code{dataOrigin} returns a \code{character} vector (same length than
\code{object}) with the origin of the spectra. \code{dataOrigin<-} expects a
\code{character} vector (same length than \code{object}) with the replacement
values for the data origin of each spectrum.
\item \code{dataStorage}: returns a \code{character} vector (same length than \code{object})
with the data storage location of each spectrum.
\item \code{intensity}: gets the intensity values from the spectra. Returns
a \code{\link[=NumericList]{NumericList()}} of \code{numeric} vectors (intensity values for each
spectrum). The length of the list is equal to the number of
\code{spectra} in \code{object}.
\item \code{ionCount}: returns a \code{numeric} with the sum of intensities for
each spectrum. If the spectrum is empty (see \code{isEmpty}),
\code{NA_real_} is returned.
\item \code{isCentroided}: a heuristic approach assessing if the spectra in
\code{object} are in profile or centroided mode. The function takes
the \code{qtl}th quantile top peaks, then calculates the difference
between adjacent m/z value and returns \code{TRUE} if the first
quartile is greater than \code{k}. (See \code{Spectra:::.isCentroided} for
the code.)
\item \code{isEmpty}: checks whether a spectrum in \code{object} is empty
(i.e. does not contain any peaks). Returns a \code{logical} vector of
length equal number of spectra.
\item \code{isolationWindowLowerMz}, \code{isolationWindowLowerMz<-}: gets or sets the lower
m/z boundary of the isolation window.
\item \code{isolationWindowTargetMz}, \code{isolationWindowTargetMz<-}: gets or sets the
target m/z of the isolation window.
\item \code{isolationWindowUpperMz}, \code{isolationWindowUpperMz<-}: gets or sets the upper
m/z boundary of the isolation window.
\item \code{length}: gets the number of spectra in the object.
\item \code{msLevel}: gets the spectra's MS level. Returns an integer vector (names
being spectrum names, length equal to the number of spectra) with the MS
level for each spectrum.
\item \code{mz}: gets the mass-to-charge ratios (m/z) from the
spectra. Returns a \code{\link[=NumericList]{NumericList()}} or length equal to the number of
spectra, each element a \code{numeric} vector with the m/z values of
one spectrum.
\item \code{peaks}: gets the \emph{peaks} matrices for all spectra in \code{object}. The function
returns a \code{\link[=SimpleList]{SimpleList()}} of matrices, each \code{matrix} with columns \code{mz} and
\code{intensity} with the m/z and intensity values for all peaks of a spectrum.
\item \code{peaksCount}: gets the number of peaks (m/z-intensity values) per
spectrum. Returns an \code{integer} vector (length equal to the
number of spectra). For empty spectra, \code{NA_integer_} is returned.
\item \code{polarity}, \code{polarity<-}: gets or sets the polarity for each
spectrum.  \code{polarity} returns an \code{integer} vector (length equal
to the number of spectra), with \code{0} and \code{1} representing negative
and positive polarities, respectively. \code{polarity<-} expects an
\code{integer} vector of length 1 or equal to the number of spectra.
\item \code{precursorCharge}, \code{precursorIntensity}, \code{precursorMz},
\code{precScanNum}, \code{precAcquisitionNum}: gets the charge (\code{integer}),
intensity (\code{numeric}), m/z (\code{numeric}), scan index (\code{integer})
and acquisition number (\code{interger}) of the precursor for MS level

2 spectra from the object. Returns a vector of length equal to
the number of spectra in \code{object}. \code{NA} are reported for MS1
spectra of if no precursor information is available.
\item \code{rtime}, \code{rtime<-}: gets or sets the retention times (in seconds)
for each spectrum.  \code{rtime} returns a \code{numeric} vector (length
equal to the number of spectra) with the retention time for each
spectrum.  \code{rtime<-} expects a numeric vector with length equal
to the number of spectra.
\item \code{scanIndex}: returns an \code{integer} vector with the \emph{scan index}
for each spectrum. This represents the relative index of the
spectrum within each file. Note that this can be different to the
\code{acquisitionNum} of the spectrum which represents the index of the
spectrum during acquisition/measurement (as reported in the mzML file).
\item \code{smoothed},\code{smoothed<-}: gets or sets whether a spectrum is
\emph{smoothed}. \code{smoothed} returns a \code{logical} vector of length equal
to the number of spectra. \code{smoothed<-} takes a \code{logical} vector
of length 1 or equal to the number of spectra in \code{object}.
\item \code{spectraData}, \code{spectraData<-}: gets or sets general spectrum
metadata (annotation, also called header). \code{spectraData} returns
a \code{DataFrame}, \code{spectraData<-} expects a \code{DataFrame}. Note that not all
backends support replacing all spectra variables (the \code{\link[=MsBackendMzR]{MsBackendMzR()}}
does for example not allow to replace \code{mz} and \code{intensity} values with the
\code{spectraData<-} method.
\item \code{spectraNames}, \code{spectraNames<-}: gets or sets the spectra names.
\item \code{spectraVariables}: returns a \code{character} vector with the
available spectra variables (columns, fields or attributes)
available in \code{object}.
\item \code{tic}: gets the total ion current/count (sum of signal of a
spectrum) for all spectra in \code{object}. By default, the value
reported in the original raw data file is returned. For an empty
spectrum, \code{0} is returned.
}
}

\section{Data subsetting, filtering and merging}{


Subsetting and filtering of \code{Spectra} objects can be performed with the below
listed methods.
\itemize{
\item \code{[}: subsets the spectra keeping only selected elements (\code{i}). The method
\strong{always} returns a \code{Spectra} object.
\item \code{filterAcquisitionNum}: filters the object keeping only spectra matching
the provided acquisition numbers (argument \code{n}). If \code{dataOrigin} or
\code{dataStorage} is also provided, \code{object} is subsetted to the spectra with
an acquisition number equal to \code{n} \strong{in spectra with matching dataOrigin
or dataStorage values} retaining all other spectra.
Returns the filtered \code{Spectra}.
\item \code{filterDataOrigin}: filters the object retaining spectra matching the
provided \code{dataOrigin}. Parameter \code{dataOrigin} has to be of type
\code{character} and needs to match exactly the data origin value of the
spectra to subset.
Returns the filtered \code{Spectra} object (with spectra ordered according to
the provided \code{dataOrigin} parameter).
\item \code{filterDataStorage}: filters the object retaining spectra stored in the
specified \code{dataStorage}. Parameter \code{dataStorage} has to be of type
\code{character} and needs to match exactly the data storage value of the
spectra to subset.
Returns the filtered \code{Spectra} object (with spectra ordered according to
the provided \code{dataStorage} parameter).
\item \code{filterEmptySpectra}: removes empty spectra (i.e. spectra without peaks).
Returns the filtered \code{Spectra} object (with spectra in their
original order).
\item \code{filterIsolationWindow}: retains spectra that contain \code{mz} in their
isolation window m/z range (i.e. with an \code{isolationWindowLowerMz} <= \code{mz}
and \code{isolationWindowUpperMz} >= \code{mz}. Returns the filtered \code{Spectra}
object (with spectra in their original order).
\item \code{filterMsLevel}: filters object by MS level keeping only spectra matching
the MS level specified with argument \code{msLevel}. Returns the filtered
\code{Spectra} (with spectra in their original order).
\item \code{filterPolarity}: filters the object keeping only spectra matching the
provided polarity. Returns the filtered \code{Spectra} (with spectra in their
original order).
\item \code{filterPrecursorMz}: retains spectra with an m/z matching the provided \code{mz}
accepting also a small difference in m/z which can be defined by parameter
\code{ppm} (parts per million). With the default (\code{ppm = 0}) only spectra with
m/z identical to \code{mz} are retained. Returns the filtered \code{Spectra} (with
spectra in their original order).
\item \code{filterPrecursorScan}: retains parent (e.g. MS1) and children scans (e.g.
MS2) of acquisition number \code{acquisitionNum}. Returns the filtered
\code{Spectra} (with spectra in their original order).
\item \code{filterRt}: retains spectra of MS level \code{msLevel} with retention
times (in seconds) within (\code{>=}) \code{rt[1]} and (\code{<=})
\code{rt[2]}. Returns the filtered \code{Spectra} (with spectra in their
original order).
\item \code{selectSpectraVariables}: reduces the information within the object to
the selected spectra variables: all data for variables not specified will
be dropped. For mandatory columns (such as \emph{msLevel}, \emph{rtime} ...) only
the values will be dropped, while additional (user defined) spectra
variables will be completely removed. Returns the filtered \code{Spectra}.
}

Several \code{Spectra} objects can be concatenated into a single object with the
\code{c} function. Concatenation will fail if the processing queue of any of the
\code{Spectra} objects is not empty or if different backends are used in the
\code{Spectra} objects. The spectra variables of the resulting \code{Spectra}
object is the union of the spectra variables of the individual \code{Spectra}
objects.
}

\section{Data manipulation and analysis methods}{


Many data manipulation operations, such as those listed in this section, are
not applied immediately to the spectra, but added to a
\emph{lazy processing/manipulation queue}. Operations stored in this queue are
applied on-the-fly to spectra data each time it is accessed. This lazy
execution guarantees the same functionality for \code{Spectra} objects with
any backend, i.e. backends supporting to save changes to spectrum data
(\code{\link[=MsBackendDataFrame]{MsBackendDataFrame()}} or \code{\link[=MsBackendHdf5Peaks]{MsBackendHdf5Peaks()}}) as well as read-only
backends (such as the \code{\link[=MsBackendMzR]{MsBackendMzR()}}). Note that for the former it is
possible to apply the processing queue and write the modified peak data back
to the data storage with the \code{applyProcessing} function.
\itemize{
\item \code{addProcessing}: adds an arbitrary function that should be applied to the
peaks matrix of every spectrum in \code{object}. The function (can be passed
with parameter \code{FUN}) is expected to take a peaks matrix as input and to
return a peaks matrix. A peaks matrix is a numeric matrix with two columns,
the first containing the m/z values of the peaks and the second the
corresponding intensities. The function has to have \code{...} in its
definition. Additional arguments can be passed with \code{...}. Examples are
provided in the package vignette.
\item \code{applyProcessing}: for \code{Spectra} objects that use a \strong{writeable} backend
only: apply all steps from the lazy processing queue to the peak data and
write it back to the data storage. Parameter \code{f} allows to specify how
\code{object} should be split for parallel processing. This should either be
equal to the \code{dataStorage}, or \code{f = rep(1, length(object))} to disable
parallel processing alltogether. Other partitionings might result in
errors (especially if a \code{MsBackendHdf5Peaks} backend is used.
\item \code{clean}: removes 0-intensity data points. For \code{all = FALSE} (the default)
0-intensity peaks next to non-zero intensity peaks are retained while with
\code{all = TRUE} all 0-intensity peaks are removed.
\item \code{removePeaks}: \emph{removes} peaks lower or equal to a threshold intensity
value \code{t} by setting their intensity to \code{0}. With the default \code{t = "min"}
all peaks with an intensity smaller or equal to the minimal non-zero
intensity is set to \code{0}. If the spectrum is in profile mode, ranges of
successive non-0 peaks <= \code{t} are set to 0. If the spectrum is centroided,
then individual peaks <= \code{t} are set to 0. Note that the number of peaks
is not changed unless \code{clean} is called after \code{removePeaks}.
}
}

\examples{

## Create a Spectra providing a `DataFrame` containing the spectrum data.

spd <- DataFrame(msLevel = c(1L, 2L), rtime = c(1.1, 1.2))
spd$mz <- list(c(100, 103.2, 104.3, 106.5), c(45.6, 120.4, 190.2))
spd$intensity <- list(c(200, 400, 34.2, 17), c(12.3, 15.2, 6.8))

data <- Spectra(spd)
data

## Create a Spectra from mzML files and use the `MsBackendMzR` on-disk
## backend.
sciex_file <- dir(system.file("sciex", package = "msdata"), full.names = TRUE)
sciex <- Spectra(sciex_file, backend = MsBackendMzR())
sciex

## The MS data is on disk and will be read into memory on-demand. We can
## however change the backend to a MsBackendDataFrame backend which will
## keep all of the data in memory.
sciex_im <- setBackend(sciex, MsBackendDataFrame())
sciex_im

## The on-disk object `sciex` is light-weight, because it does not keep the
## MS peak data in memory. The `sciex_im` object in contrast keeps all the
## data in memory and its size is thus much larger.
object.size(sciex)
object.size(sciex_im)

## The spectra variable `dataStorage` returns for each spectrum the location
## where the data is stored. For in-memory objects:
head(dataStorage(sciex_im))

## While objects that use an on-disk backend will list the files where the
## data is stored.
head(dataStorage(sciex))

## The spectra variable `dataOrigin` returns for each spectrum the *origin*
## of the data. If the data is read from e.g. mzML files, this will be the
## original mzML file name:
head(dataOrigin(sciex))
head(dataOrigin(sciex_im))

## ---- ACCESSING AND ADDING DATA ----

## Get the MS level for each spectrum.
msLevel(data)

## Alternatively, we could also use $ to access a specific spectra variable.
## This could also be used to add additional spectra variables to the
## object (see further below).
data$msLevel

## Get the intensity and m/z values.
intensity(data)
mz(data)

## Accessing spectra variables works for all backends:
intensity(sciex)
intensity(sciex_im)

## Get the m/z for the first spectrum.
mz(data)[[1]]

## Get the peak data (m/z and intensity values).
pks <- peaks(data)
pks
pks[[1]]
pks[[2]]

## List all available spectra variables (i.e. spectrum data and metadata).
spectraVariables(data)

## For all *core* spectrum variables accessor functions are available. These
## return NA if the variable was not set.
centroided(data)
dataStorage(data)
rtime(data)
precursorMz(data)

## Add an additional metadata column.
data$spectrum_id <- c("sp_1", "sp_2")

## List spectra variables, "spectrum_id" is now also listed
spectraVariables(data)

## Get the values for the new spectra variable
data$spectrum_id

## Extract specific spectra variables.
spectraData(data, columns = c("spectrum_id", "msLevel"))

## Drop spectra variable data and/or columns.
res <- selectSpectraVariables(data, c("mz", "intensity"))

## This removed the additional columns "spectrum_id" and deleted all values
## for all spectra variables, except "mz" and "intensity".
spectraData(res)

## Compared to the data before selectSpectraVariables.
spectraData(data)


## ---- SUBSETTING, FILTERING AND COMBINING

## Subset to all MS2 spectra.
data[msLevel(data) == 2]

## Same with the filterMsLevel function
filterMsLevel(data, 2)

## Below we combine the `data` and `sciex_im` objects into a single one.
data_comb <- c(data, sciex_im)

## The combined Spectra contains a union of all spectra variables:
head(data_comb$spectrum_id)
head(data_comb$rtime)
head(data_comb$dataStorage)
head(data_comb$dataOrigin)

## ---- DATA MANIPULATIONS ----

## Set the data to be centroided
centroided(data) <- TRUE

## Remove peaks with an intensity below 40.
res <- removePeaks(data, t = 40)
res

## Get the intensities of the first and second spectrum.
intensity(res)[[1]]
intensity(res)[[2]]

## Clean all spectra removing all 0-intensity peaks.
res <- clean(res, all = TRUE)

## Get the intensities of the first and second spectrum.
intensity(res)[[1]]
intensity(res)[[2]]

## Second spectrum is now empty:
isEmpty(res)
}
\author{
Sebastian Gibb, Johannes Rainer
}
