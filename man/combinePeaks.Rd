% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/peak-list-functions.R
\name{combinePeaks}
\alias{combinePeaks}
\title{Combine peaks with similar m/z across spectra}
\usage{
combinePeaks(x, intensityFun = base::mean, mzFun = base::mean,
  weighted = FALSE, tolerance = 0, ppm = 0, timeDomain = FALSE,
  main = 1L, unionPeaks = TRUE, ...)
}
\arguments{
\item{x}{\code{list} of peak matrices.}

\item{intensityFun}{\code{function} to be used to combine intensity values for
matching peaks. By default the mean intensity value is returned.}

\item{mzFun}{\code{function} to be used to combine m/z values for matching peaks.
By default the mean m/z value is returned.}

\item{weighted}{\code{logical(1)} defining whether m/z values for matching peaks
should be calculated by an intensity-weighted average of the individuak
m/z values. This overrides parameter \code{mzFun}.}

\item{tolerance}{\code{numeric(1)} defining the (absolute) maximal accepted
difference between mass peaks to group them into the same final peak.}

\item{ppm}{\code{numeric(1)} defining the m/z-relative maximal accepted
difference between mass peaks (expressed in parts-per-million) to group
them into the same final peak.}

\item{timeDomain}{\code{logical(1)} whether grouping of mass peaks is performed
on the m/z values (\code{timeDomain = FALSE}) or on \code{sqrt(mz)}
(\code{timeDomain = TRUE}).}

\item{main}{\code{integer(1)} defining the \emph{main} spectrum. Only used for
\code{unionPeaks = FALSE}.}

\item{unionPeaks}{\code{logical(1)} defining whether the union of all peaks from
all spectra are reported (\code{unionPeaks = TRUE}, the default) or only
peaks present in the \emph{main} spectrum defined by \code{main}
(\code{unionPeaks = FALSE}).}

\item{...}{additional parameters to the \code{mzFun} and \code{intensityFun} functions.}
}
\value{
Peaks \code{matrix} with m/z and intensity values representing the aggregated
values across the provided peak matrices.
}
\description{
\code{combinePeaks} aggregates provided peak matrices into a single peak matrix.
Peaks are grouped by their m/z values with the \code{group()} function from the
\code{MsCoreUtils} package. All peaks in all provided spectra are first ordered
by their m/z and consecutively grouped into one group if the (pairwise)
difference between them is smaller than specified with parameter \code{tolerance}
and \code{ppm} (see \code{\link[=group]{group()}} for grouping details and examples).

The m/z and intensity values for the resulting peak matrix are calculated
using the \code{mzFun} and \code{intensityFun} on the grouped m/z and intensity values.

Parameters \code{main} and \code{unionPeaks} deal with special cases if e.g. only
peaks should be reported that are present in one of the provided peak
matrices. If for example \code{main = 2L} and \code{unionPeaks = FALSE}, only peaks
are returned wich are present in the second peak matrix.

Setting \code{timeDomain} to \code{TRUE} causes grouping to be performed on the square
root of the m/z values.
}
\details{
For general merging of spectra, the \code{tolerance} and/or \code{ppm} should be
manually specified based on the precision of the MS instrument. Peaks
from spectra with a difference in their m/z being smaller than \code{tolerance}
or smaller than \code{ppm} of their m/z are grouped into the same final peak.

Some details for the combination of consecutive spectra of an LC-MS run:

The m/z values of the same ion in consecutive scans (spectra) of a LC-MS run
will not be identical. Assuming that this random variation is much smaller
than the resolution of the MS instrument (i.e. the difference between
m/z values within each single spectrum), m/z value groups are defined
across the spectra and those containing m/z values of the \code{main} spectrum
are retained.
Intensities and m/z values falling within each of these m/z groups are
aggregated using the \code{intensityFun} and \code{mzFun}, respectively. It is
highly likely that all QTOF profile data is collected with a timing circuit
that collects data points with regular intervals of time that are then later
converted into m/z values based on the relationship \code{t = k * sqrt(m/z)}. The
m/z scale is thus non-linear and the m/z scattering (which is in fact caused
by small variations in the time circuit) will thus be different in the lower
and upper m/z scale. m/z-intensity pairs from consecutive scans to be
combined are therefore defined by default on the square root of the m/z
values. With \code{timeDomain = FALSE}, the actual m/z values will be used.
}
\examples{

set.seed(123)
mzs <- seq(1, 20, 0.1)
ints1 <- abs(rnorm(length(mzs), 10))
ints1[11:20] <- c(15, 30, 90, 200, 500, 300, 100, 70, 40, 20) # add peak
ints2 <- abs(rnorm(length(mzs), 10))
ints2[11:20] <- c(15, 30, 60, 120, 300, 200, 90, 60, 30, 23)
ints3 <- abs(rnorm(length(mzs), 10))
ints3[11:20] <- c(13, 20, 50, 100, 200, 100, 80, 40, 30, 20)

## Create the peaks matrices
p1 <- cbind(mz = mzs + rnorm(length(mzs), sd = 0.01),
    intensity = ints1)
p2 <- cbind(mz = mzs + rnorm(length(mzs), sd = 0.01),
    intensity = ints2)
p3 <- cbind(mz = mzs + rnorm(length(mzs), sd = 0.009),
    intensity = ints3)

## Combine the spectra. With `tolerance = 0` and `ppm = 0` only peaks with
## **identical** m/z are combined. The result will be a single spectrum
## containing the *union* of mass peaks from the individual input spectra.
p <- combinePeaks(list(p1, p2, p3))

## Plot the spectra before and after combining
par(mfrow = c(2, 1), mar = c(4.3, 4, 1, 1))
plot(p1[, 1], p1[, 2], xlim = range(mzs[5:25]), type = "h", col = "red")
points(p2[, 1], p2[, 2], type = "h", col = "green")
points(p3[, 1], p3[, 2], type = "h", col = "blue")

plot(p[, 1], p[, 2], xlim = range(mzs[5:25]), type = "h",
    col = "black")

## Combine spectra with `tolerance = 0.05`. This will merge all triplets.
p <- combinePeaks(list(p1, p2, p3), tolerance = 0.05)

## Plot the spectra before and after combining
par(mfrow = c(2, 1), mar = c(4.3, 4, 1, 1))
plot(p1[, 1], p1[, 2], xlim = range(mzs[5:25]), type = "h", col = "red")
points(p2[, 1], p2[, 2], type = "h", col = "green")
points(p3[, 1], p3[, 2], type = "h", col = "blue")

plot(p[, 1], p[, 2], xlim = range(mzs[5:25]), type = "h",
    col = "black")

## With `intensityFun = max` the maximal intensity per peak is reported.
p <- combinePeaks(list(p1, p2, p3), tolerance = 0.05,
    intensityFun = max)
}
\seealso{
Other peak matrix combining functions: \code{\link{consensusPeaks}}
}
\author{
Johannes Rainer
}
\concept{peak matrix combining functions}
